{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome This website is intended to provide the ressources for the students following the micro:bit mobile robotics summerschool. But those ressources have been produced to be reusable, and teachers are of course welcomed to go through this site and take whatever they like for their own courses. Overall, the program of the summerschool will be as follows: The structure of this site follows the chronology of the activities you will go through (before and) during the week of the summerschool: Introduction to python As most of the activities will include some python programming, I'll need everyone to come with a minimum of experience of this langage so that we can go through all the activities without leaving anyone behind. This is the purpose of this page which will make you practice the basics of python and discover the different tools you'll need during the week if you don't know them already. Micro:bit board (the links will come during the summerschool) On monday you will discover the micro:bit controller which will be the brain of our mobile robots. You'll use your (freshly gained) skills in python to already start interacting with the board. In the afternoon, you'll start to discover how to connect a controller to sensors and actuators , that is how to give him more the ability to sense and act on its environment. Robotics and moving While previously we were limited to a bunch of components lyind around next to each other, on tuesday wou'll add a bit of structure to all this. You'll put together a simple mobile robot kit and learn to control it. In the afternoon, you'll work on the same theme, but learning to gain autonomy to decompose and solve robotics problems without guidance. Designing and building The robot we find in kits is rarelly able to satisfies all our desires. To free us from those limitations, we'll see how to design our own robot frame and build it using simple equipment first, in the morning, then using professional equipment and CAD in the afternoon. Closing and opening In the last day we'll come back on what we learned and produced during the week and you will be presented different options to contiune your exploration of mobile robotics smoothly in autonnomy. Have a good time and may you learn a lot !","title":"Welcome"},{"location":"#welcome","text":"This website is intended to provide the ressources for the students following the micro:bit mobile robotics summerschool. But those ressources have been produced to be reusable, and teachers are of course welcomed to go through this site and take whatever they like for their own courses. Overall, the program of the summerschool will be as follows: The structure of this site follows the chronology of the activities you will go through (before and) during the week of the summerschool: Introduction to python As most of the activities will include some python programming, I'll need everyone to come with a minimum of experience of this langage so that we can go through all the activities without leaving anyone behind. This is the purpose of this page which will make you practice the basics of python and discover the different tools you'll need during the week if you don't know them already. Micro:bit board (the links will come during the summerschool) On monday you will discover the micro:bit controller which will be the brain of our mobile robots. You'll use your (freshly gained) skills in python to already start interacting with the board. In the afternoon, you'll start to discover how to connect a controller to sensors and actuators , that is how to give him more the ability to sense and act on its environment. Robotics and moving While previously we were limited to a bunch of components lyind around next to each other, on tuesday wou'll add a bit of structure to all this. You'll put together a simple mobile robot kit and learn to control it. In the afternoon, you'll work on the same theme, but learning to gain autonomy to decompose and solve robotics problems without guidance. Designing and building The robot we find in kits is rarelly able to satisfies all our desires. To free us from those limitations, we'll see how to design our own robot frame and build it using simple equipment first, in the morning, then using professional equipment and CAD in the afternoon. Closing and opening In the last day we'll come back on what we learned and produced during the week and you will be presented different options to contiune your exploration of mobile robotics smoothly in autonnomy. Have a good time and may you learn a lot !","title":"Welcome"},{"location":"about/","text":"About the author After a few years in computer science research, working on very stimulating subjects such as autonomous robotics, augmented reality, 3D reconstruction and machine learning, my pleasure to share my enthusiasm for computer science has been growing. So, from computer science research I made a smooth transition to teaching it. I enjoy computer science because it offers me an infinite source of puzzles, but it's not the only reason. I think that understanding computers and having skills in the field is paramount to understanding our world which is becoming more and more digital. So I wish for everyone to know that the computer science world is open to them. and I hope to give the keys to this world to as many people as possible in the future. Luckily I joined a wonderfull team in EPFL which has a similar goal as mine (among others). That's how I ended up co animating the Thymio mobile robotics summer school with Professor Francesco Mondada to progressively animate the whole thing. Finally COVID19 forced us to search for an online format, which led me to propose a new form of summerschool based on micro:bit. Collaborators This summerschool won't be possible without the support of the Service de Promotion de l'Education of EPFL. It also wouldn't have been possible without the trust that Prof. F. Mondada gave me and the opportunities he gave me coanimating, animating and tinkering in the previous editions of the summerschool. I'm also thankfull for the help of Christian Chang, Anthony Guinchard and Aditya Mehrotra, for the inspiration they gave me to integrate a makers touch and for their help in the preparation of the program, the ressources and in the animation. Contact Find the information to contact me on my professional page .","title":"Contacts"},{"location":"about/#about-the-author","text":"After a few years in computer science research, working on very stimulating subjects such as autonomous robotics, augmented reality, 3D reconstruction and machine learning, my pleasure to share my enthusiasm for computer science has been growing. So, from computer science research I made a smooth transition to teaching it. I enjoy computer science because it offers me an infinite source of puzzles, but it's not the only reason. I think that understanding computers and having skills in the field is paramount to understanding our world which is becoming more and more digital. So I wish for everyone to know that the computer science world is open to them. and I hope to give the keys to this world to as many people as possible in the future. Luckily I joined a wonderfull team in EPFL which has a similar goal as mine (among others). That's how I ended up co animating the Thymio mobile robotics summer school with Professor Francesco Mondada to progressively animate the whole thing. Finally COVID19 forced us to search for an online format, which led me to propose a new form of summerschool based on micro:bit.","title":"About the author"},{"location":"about/#collaborators","text":"This summerschool won't be possible without the support of the Service de Promotion de l'Education of EPFL. It also wouldn't have been possible without the trust that Prof. F. Mondada gave me and the opportunities he gave me coanimating, animating and tinkering in the previous editions of the summerschool. I'm also thankfull for the help of Christian Chang, Anthony Guinchard and Aditya Mehrotra, for the inspiration they gave me to integrate a makers touch and for their help in the preparation of the program, the ressources and in the animation.","title":"Collaborators"},{"location":"about/#contact","text":"Find the information to contact me on my professional page .","title":"Contact"},{"location":"cad/","text":"Computer-aided design (CAD) While this morning you learned a great way to get familiar with standard mecanical problems of robotics and an easy way to prototype a design, you will often want and need to build something clean. For this you could learn machining, but you could instead learn to do the same with the help of computers which is what you'll do this afternoon. Drawing Cutting Cutted parts Mounting To build a frame using computers, the process consists of two phases: first, designing using a CAD software, second, building using a machine that accepts to take as input your CAD. Today you'll learn how to do the first phase using an online software called Tinkercad. You'll do this with the goal to eventually cut your model in 3mm thick sheets of plexiglass using a laser cutter as shown in the picture above (you can get access to those in fablabs which are becoming more and more common in Switzerland). Starting with laser cutting has the advantage of being very similar to the cardboard you used this morning in terms of mecanics. What you will need Every pair of learners will need: A computer equipped with a connection to internet and a browser. Introduction to Tinkercad In this activity, you will learn the basics of CAD designing by reproducing the 3D model shown above of a robot very similar to the one we used this week. For this, go onto this virtual classroom . This will allow you to access tinkercad using only a nickname that your teacher will give you. That will also allow us to follow your progress and help you if you need. Then follow the instruction videos here ( todo ). Video 1: Connect to the class with your nickname create a new empty design add an object changing the point of view changing the size move the object in space join two objects together make an object as a hole and substract it from another object Video 2: import the Parts do a simple version of the buggy Project The project will be given to you during the week. Conclusion","title":"Cad"},{"location":"cad/#computer-aided-design-cad","text":"While this morning you learned a great way to get familiar with standard mecanical problems of robotics and an easy way to prototype a design, you will often want and need to build something clean. For this you could learn machining, but you could instead learn to do the same with the help of computers which is what you'll do this afternoon. Drawing Cutting Cutted parts Mounting To build a frame using computers, the process consists of two phases: first, designing using a CAD software, second, building using a machine that accepts to take as input your CAD. Today you'll learn how to do the first phase using an online software called Tinkercad. You'll do this with the goal to eventually cut your model in 3mm thick sheets of plexiglass using a laser cutter as shown in the picture above (you can get access to those in fablabs which are becoming more and more common in Switzerland). Starting with laser cutting has the advantage of being very similar to the cardboard you used this morning in terms of mecanics.","title":"Computer-aided design (CAD)"},{"location":"cad/#what-you-will-need","text":"Every pair of learners will need: A computer equipped with a connection to internet and a browser.","title":"What you will need"},{"location":"cad/#introduction-to-tinkercad","text":"In this activity, you will learn the basics of CAD designing by reproducing the 3D model shown above of a robot very similar to the one we used this week. For this, go onto this virtual classroom . This will allow you to access tinkercad using only a nickname that your teacher will give you. That will also allow us to follow your progress and help you if you need. Then follow the instruction videos here ( todo ). Video 1: Connect to the class with your nickname create a new empty design add an object changing the point of view changing the size move the object in space join two objects together make an object as a hole and substract it from another object Video 2: import the Parts do a simple version of the buggy","title":"Introduction to Tinkercad"},{"location":"cad/#project","text":"The project will be given to you during the week.","title":"Project"},{"location":"cad/#conclusion","text":"","title":"Conclusion"},{"location":"cardbot/","text":"Designing a robot In the previous days we learned how to control a robot, to make it move, to add sensors to its controller, but we did not yet manage to have what we could call an autonomous robot. Today you will learn how to make this possible. Question With everything you learned so far and the material at hand, do you think that you could put together an autonomous mobile robot that will explore it's surrounding while avoiding obstacles ? Answer Yes you might be able to. Indeed, while you can't connect the HC-SR04 and 2 motors on the buggy board, you can connect the ultrasonic sensor on one board and two motors on another board and make the two board communicate. The problem is that the robot frame of the buggy does not allow that. Today you'll learn how to start prototyping andd building your own frames to solve such problems. What you will need Every pair of learners will need: A computer equipped with a connection to internet and a browser (ideally Chrome), One micro:bit, A usb cable to connect the micro:bit to the computer, One bit:buggy kit, Some cardboard, A ruler, A cutter. Cardbot Why we'll use carboard ? Why we'll provide the first design? Build the cardboard buggy by following the instructions below: Missing the space for the switch in my version Draw Cut, dismantle the buggy and discard elements on left Mount the wheels Put half of the rivets in Mount the universal wheel Mount the buggy board Fold and mount the motors Plug the motors and put the two parts together Figure: Mounting the cardbot. Please put the discarded elements back in the buggy box, taking care of putting the screws back in their plastic bags. Obstacle avoiding robot design In this activity you will take the time to propose your own design to solve the original problem which was to build an obstacle avoiding robot. Exercise 1 1.1 Design (without building) a new frame for your robot to be able to explore its environment and detect obstacles. 1.2 Choose among your design and the one proposed design which of the two you prefer and build it. 1.3 Program the mobile robot to explore the space and avoid obstacles. Conclusion This morning you learned how to design and build a robot frame with simple material. While there is a lot to learn in the field of mecanics, the theory is based on some strong fundations in physics and geometry. However, there si no need to get involved in the theory too hurly. You can already learn a lot of practical knowledge in doing what you did this morning, and this will only makes you learn the theory more easily later if you are interested in this field.","title":"Cardbot"},{"location":"cardbot/#designing-a-robot","text":"In the previous days we learned how to control a robot, to make it move, to add sensors to its controller, but we did not yet manage to have what we could call an autonomous robot. Today you will learn how to make this possible. Question With everything you learned so far and the material at hand, do you think that you could put together an autonomous mobile robot that will explore it's surrounding while avoiding obstacles ? Answer Yes you might be able to. Indeed, while you can't connect the HC-SR04 and 2 motors on the buggy board, you can connect the ultrasonic sensor on one board and two motors on another board and make the two board communicate. The problem is that the robot frame of the buggy does not allow that. Today you'll learn how to start prototyping andd building your own frames to solve such problems.","title":"Designing a robot"},{"location":"cardbot/#what-you-will-need","text":"Every pair of learners will need: A computer equipped with a connection to internet and a browser (ideally Chrome), One micro:bit, A usb cable to connect the micro:bit to the computer, One bit:buggy kit, Some cardboard, A ruler, A cutter.","title":"What you will need"},{"location":"cardbot/#cardbot","text":"Why we'll use carboard ? Why we'll provide the first design? Build the cardboard buggy by following the instructions below: Missing the space for the switch in my version Draw Cut, dismantle the buggy and discard elements on left Mount the wheels Put half of the rivets in Mount the universal wheel Mount the buggy board Fold and mount the motors Plug the motors and put the two parts together Figure: Mounting the cardbot. Please put the discarded elements back in the buggy box, taking care of putting the screws back in their plastic bags.","title":"Cardbot"},{"location":"cardbot/#obstacle-avoiding-robot-design","text":"In this activity you will take the time to propose your own design to solve the original problem which was to build an obstacle avoiding robot. Exercise 1 1.1 Design (without building) a new frame for your robot to be able to explore its environment and detect obstacles. 1.2 Choose among your design and the one proposed design which of the two you prefer and build it. 1.3 Program the mobile robot to explore the space and avoid obstacles.","title":"Obstacle avoiding robot design"},{"location":"cardbot/#conclusion","text":"This morning you learned how to design and build a robot frame with simple material. While there is a lot to learn in the field of mecanics, the theory is based on some strong fundations in physics and geometry. However, there si no need to get involved in the theory too hurly. You can already learn a lot of practical knowledge in doing what you did this morning, and this will only makes you learn the theory more easily later if you are interested in this field.","title":"Conclusion"},{"location":"further/","text":"Going further Here are ways you could follow to deepenn your knowledge and practice in mobile robotics while still taking incremental steps. Controllers Challenge: create an autonomous robot base on arduino. Keep the same sensors and actuators, as a result you'll only have to learn to program in C++ and find a way to power the arduino (I'd recommand using a power bank) Sensors Challenge: make a robot that follows the light => keep the same controller, the micro:bit, and learn to use new sensors. The challenge could be to learn to use new distance sensors (sharp, TOF). What are their advantages, disadvantages ? Actuators Challenge: Make a robot that goes much faster, for this you'll have only to change the motors. One way could be to use DC motors. Other challenge: make the robot more precise in its displacement => use stepper motors. Extension board and electronics Challenge: find a way to get access to more inputs and outputs => new extension board and power supply. Making Challenge: Get in the closest fablab and laser cut or 3D print your own frame to hold all the electronics together. Or build any automaton with simple material you can find at home.","title":"Going further"},{"location":"further/#going-further","text":"Here are ways you could follow to deepenn your knowledge and practice in mobile robotics while still taking incremental steps.","title":"Going further"},{"location":"further/#controllers","text":"Challenge: create an autonomous robot base on arduino. Keep the same sensors and actuators, as a result you'll only have to learn to program in C++ and find a way to power the arduino (I'd recommand using a power bank)","title":"Controllers"},{"location":"further/#sensors","text":"Challenge: make a robot that follows the light => keep the same controller, the micro:bit, and learn to use new sensors. The challenge could be to learn to use new distance sensors (sharp, TOF). What are their advantages, disadvantages ?","title":"Sensors"},{"location":"further/#actuators","text":"Challenge: Make a robot that goes much faster, for this you'll have only to change the motors. One way could be to use DC motors. Other challenge: make the robot more precise in its displacement => use stepper motors.","title":"Actuators"},{"location":"further/#extension-board-and-electronics","text":"Challenge: find a way to get access to more inputs and outputs => new extension board and power supply.","title":"Extension board and electronics"},{"location":"further/#making","text":"Challenge: Get in the closest fablab and laser cut or 3D print your own frame to hold all the electronics together. Or build any automaton with simple material you can find at home.","title":"Making"},{"location":"gpio/","text":"Input and outputs This morning we saw how the micro:bit comes equipped with integrated sensors and actuators. For mobile robotics, those are not enough, so this afternoon you'll see how it is possible to add sensors and actuators to the micro:bit to go towards our goal of building an autonomous mobile robot. What you will need Buggy mainboard Potentiometer and wires Servo motor Ultrasound sensor Figure: Necessary equipment. Every pair of learners will need: The equipment required in the previous session One bit:buggy mainboard, 5 screws and a screwdriver (all in the bit:buggy box) One potentiometer 6 Wires female-female One servo motor (in the bit:buggy box) One ultrasound sensor (the HC-SR04) 3 x AAA batteries GPIO Look at the micro:bit. On its bottom there is a strange set of golden lines (it's not gold, don't start to rip it appart and try selling it!). Those are conductive connectors that will allow you to connect more sensors and actuators to it and interact with them. They are what we call inputs and outputs or GPIO (general purpose input/ouputs) which are standards in the world of microcontrollers. Each connector is called a pin , and most of them can be used as input or output. The micro:bit has about 20 of them in total (more information here ). Adding a simple sensor The first sensor you will add is called a potentiometer. For this you will use one pin as a input. You'll learn how to capture the position of the potentiometer in our program. Before doing any programming, you will have to take care of the physical connection between the potentiometer and the micro:bit. Begin by disconnecting the micro:bit from the computer. Before doing any changes in the wiring of a controller, always power it off ! Then, screw the micro:bit on the bit:buggy mainboard using 5 screws (see figures below). This will give you access to pin0, pin1, pin2, 3.3V and Ground through femelle pin headers on the back of the buggy board. In this activity, you will use the pins pin0 (0), 3.3V (V) and ground (G). Connect the wires as shown in the image below (the colors are not important although we usually try to put a black cable for ground and a red one for power sources). Screwing onto the buggy mainboard Connecting the potentiometer Figure: Connecting the potentiometer to the micro:bit. DO NOT PUT THE BATTERIES IN YET !! You might destroy the micro:bit if you do so... In this montage, the potentiometer will ouput through S (for signal) a portion of the input voltage (3.3V) depending on the position of the knob. To access the information of the pins in python, the microbit library defines for us the objects pin0 , pin1 , etc... Those objects come with two useful functions: read_analog() or read_digital() (see doc here ). If we are interested in getting a binary information (is the voltage on the pin high or low?), we use read_digital() . That's what we'd use for a button (pressed or not). If we want more we have to use the function read_analog() . This is our case as we want to know the position of the knob, therefore, we want to know which portion of 3.3V is on pin0. Exercice 1 1.1. pin0.read_analog() returns an integer. Program micro:bit to display the value returned by this function using the function display.scroll() every 100 ms. Turn the knob to find what is the range of values that pin0.read_analog() can return. Can you display the value every 100 ms ? 1.2. Use the function displayPositiveNumber(n) defined this morning to display the position of the knob every 100 ms. Remember that this function works well only for arguments in [0-25], so you'll need to do some scaling in between. 1.3. (Optional) If you are not comfortable with linear mapping (rescaling in our case), you could later take the time to define a function to do that for you so that map(n, n_min,n_max,res_min,res_max) = res_min + n.(res_max-res_min)/(n_max-n_min) . Solution exercice 1.1 The value returned by read_analog() is not in any physical unit. It's just a number encoded in 10 bits, meaning that it's value can go theoretically from 0 to 1024. However, this corresponds to the measure of a voltage on pin0 that can go from 0 to 3.3V (and should never go above 3.3V !). While there exist many kinds of sensors, many of them work in a similar fashion as the potentiometer. A sensor will often require a power source (3.3Volts and ground), and it will output a signal. Controlling a motor Now that the micro:bit can sense, you will learn how to make it act on its environment with a motor. For this get one of the motors out of the bit:buggy kit. Notice that the motor comes with its cable. Power off the micro:bit by disconnecting it from the computer , then plug the motor as shown in the image below (connection on pin1, taking care of putting the brown/black wire facing the letter G). To make the rotation of the motor more noticeable, you can take one of the white plastic end that comes in the bag where you found the motor. This piece is called a servo horn and allow for easy mechanical constructions with the motor. Figure: Connecting the servo motor to the micro:bit. There are many kinds of motor. We will come back to this later. The one you'll use now is called a continuous servo motor. While the way it works will likely seem a bit obscure, it is a great choice to start with as it is very easy to control as they require no extra components. If you are just interested in making the motor turn, skip this paragraph. For the others, here is a little theory: Servo motors are controlled using pulse width modulation (PWM). PWMs are signals made out of regular high voltage pulses with varying width. The motor will measure the width of the pulses and will turn depending on it. In our case, to control the servo motor, we need to send a high pulse every 10 milliseconds. The width of the pulse needs to be 5% to 25% the period of the pulse (0.5ms to 2.5ms long) to be taken into account by the motor. More about PWMs here and to more about continuous servo motors here . Practically, to control the motor you will need to have pin1 output a high pulse with a 10 ms period. As the documentation explains, to do so we can use the instruction pin1.set_analog_period(10) . To change its speed you will have to use the function pin1.write_analog(d) with d in [50-250]. Exercice 2 2.1. Program the micro:bit to make the robot turn. Try different values for d to make it turn at different speeds. What argument do you need to give to the write_analog() function to make the motor stop ? Does the function pin1.set_analog_period(10) need to be in the loop ? 2.2. Program the micro:bit so that you can control the speed of the motor by turning the potentiometer. Notice that the motor is quite similar to the potentiometer in terms of wiring: it needs a power supply (3.3V and ground) and a signal, except that this time the signal is going from the micro:bit to the motor. This applies to many actuators. Measuring a distance The last component you will learn to interface today is the HC-SR04. The HC-SR04, while it is commonly called an \"ultrasonic distance sensor\" is both a sensor and an actuator. It sends an ultrasound signal when the controllers orders it to do so and it informs the controller when it receives an echo. Thanks to the time between emission and reception and a bit of physics ( distance = time * velocity ) we can estimate the distance of obstacles facing the sensor. Do the montage shown in the pictures below. Add the batteries only once you double checked the montage . This montage is more complex than the previous ones and here is why: The HC-SR04 needs about 5V of power and by adding the batteries the V pins of the buggy board go up from 3.3V to about 5V (more 3x1.5V in reality). The HC-SR04 sends an echo of 5V which if plugged directly to micro:bit could burn it. The montage with the potentiometer set at its mid-position allows to solve this problem 1 . Potentiometer at its mid-position Montage Circuit diagram Figure: Using the HC-SR04 with the micro:bit: set the potentiometer to its mid-position, do the wiring. One way to use the HC-SR04 in our program is to use the following function: from microbit import * import machine import utime pinTrig = pin0 pinEcho = pin1 def get_dist_in_cm(): # send a high pulse to the trigger of HC-SR04 pinTrig.write_digital(0) utime.sleep_us(2) pinTrig.write_digital(1) utime.sleep_us(10) pinTrig.write_digital(0) # measure the time in microseconds that it takes to receive a high pulse on the echo pin. d = machine.time_pulse_us(pinEcho,1,10000)# timeout in 10000 us = 0.01 s if d>0:# echo received return d/Constant else:# timeout returns -1 return d Exercice 3 3.1. Read the code to verify if it matches the sensor specifications that we defined previously. Will this work if I call the function get_dist_in_cm() ? 3.2. It won't work ! There is something missing: Constant is not defined and that's because I want you to find it now using the laws of physics. 3.3. Once you found the value of Constant , write a program to display the distance on the LED matrix using the function displayPositiveNumber(n) . Don't forget to turn the switch of the buggy board on to test your program. When the switch is on you can actually unplug the usb cable and the circuit should continue working without the computer. Disco light (optional) If you finish the exercises in advance or if you are not tired enough and you want to learn more, one more thing you could do is to use the special extension board of the buggy, and learn to control it. It comes with 2 neopixel LEDs which can be controlled thanks to the neopixel library. For instance, if the board is plugged on pin0, a simple program to light up one LED in green and one in blue would be the following: from microbit import * import neopixel np = neopixel.NeoPixel(pin0, 2) np[0] = (0, 255, 0) np[1] = (0, 0, 255) np.show() Exercice 4 Connect the neopixel and the potentiometer to the micro.bit. Program the micro:bit to select the channel (R, G or B) of the first and second LED with respectively the button A and B so that you can set the value of each channel using the potentiometer. Conclusion That's it for today. Turn the buggy mainboard off using it's switch to save the batteries for the coming days and unplug everything putting all the components back to their respective boxes. With what you've learned today, you've got all the electronics tools you need to make an autonomous robot. While this morning you learned to interact with the controller of a robot, now you know how to give it eyes and muscles. Moreover while your familiarity with the use of functions is growing, reusing the work we did today will get easier and easier. The the function displayPositiveNumber(n) made our work easier this afternoon to get a quick feedback from our sensors. All the work we did with the motor and the distance sensor this afternoon will make our work easier in the coming days. Talking about ease: this afternoon we dabbled in the world of electronics. This can be intimidating at first. But like most other domains, by repetitive explorations out of your confort zone, you make your confort zone wider and soon this field can be yours to play with. For now, time to rest and see you tomorrow for some more challenges ! While we use the potentiometer as a sensor it is essentially a voltage divider. Therefore we can use it to lower the voltage of the echo signal down. The way we used it as a sensor was to connect it with 3.3V and the ground, and it outputed a portion of 3.3V depending on the position of the knob, which is what we measured with the micro:bit. Instead, we can now feed it with the 0 to 5V echo signal coming from the HC-SR04, and make it output a portion of that, making sure it does not go over 3.3V. Also we need to take a large enough portion of the signal, for instance imagine we outputed 0% of the signal with the potentiometer, then we would not be able to understand when the echo is received on the micro:bit. To get it to work we need the high value of the signal to be 2.3 Volt minimum (2.3 = 0.7 * 3.3... see here for more information). Therefore if we put the knob at its mid position, it should output a signal oscillating in between 0 and 2.5V and it should work. \u21a9","title":"Gpio"},{"location":"gpio/#input-and-outputs","text":"This morning we saw how the micro:bit comes equipped with integrated sensors and actuators. For mobile robotics, those are not enough, so this afternoon you'll see how it is possible to add sensors and actuators to the micro:bit to go towards our goal of building an autonomous mobile robot.","title":"Input and outputs"},{"location":"gpio/#what-you-will-need","text":"Buggy mainboard Potentiometer and wires Servo motor Ultrasound sensor Figure: Necessary equipment. Every pair of learners will need: The equipment required in the previous session One bit:buggy mainboard, 5 screws and a screwdriver (all in the bit:buggy box) One potentiometer 6 Wires female-female One servo motor (in the bit:buggy box) One ultrasound sensor (the HC-SR04) 3 x AAA batteries","title":"What you will need"},{"location":"gpio/#gpio","text":"Look at the micro:bit. On its bottom there is a strange set of golden lines (it's not gold, don't start to rip it appart and try selling it!). Those are conductive connectors that will allow you to connect more sensors and actuators to it and interact with them. They are what we call inputs and outputs or GPIO (general purpose input/ouputs) which are standards in the world of microcontrollers. Each connector is called a pin , and most of them can be used as input or output. The micro:bit has about 20 of them in total (more information here ).","title":"GPIO"},{"location":"gpio/#adding-a-simple-sensor","text":"The first sensor you will add is called a potentiometer. For this you will use one pin as a input. You'll learn how to capture the position of the potentiometer in our program. Before doing any programming, you will have to take care of the physical connection between the potentiometer and the micro:bit. Begin by disconnecting the micro:bit from the computer. Before doing any changes in the wiring of a controller, always power it off ! Then, screw the micro:bit on the bit:buggy mainboard using 5 screws (see figures below). This will give you access to pin0, pin1, pin2, 3.3V and Ground through femelle pin headers on the back of the buggy board. In this activity, you will use the pins pin0 (0), 3.3V (V) and ground (G). Connect the wires as shown in the image below (the colors are not important although we usually try to put a black cable for ground and a red one for power sources). Screwing onto the buggy mainboard Connecting the potentiometer Figure: Connecting the potentiometer to the micro:bit. DO NOT PUT THE BATTERIES IN YET !! You might destroy the micro:bit if you do so... In this montage, the potentiometer will ouput through S (for signal) a portion of the input voltage (3.3V) depending on the position of the knob. To access the information of the pins in python, the microbit library defines for us the objects pin0 , pin1 , etc... Those objects come with two useful functions: read_analog() or read_digital() (see doc here ). If we are interested in getting a binary information (is the voltage on the pin high or low?), we use read_digital() . That's what we'd use for a button (pressed or not). If we want more we have to use the function read_analog() . This is our case as we want to know the position of the knob, therefore, we want to know which portion of 3.3V is on pin0. Exercice 1 1.1. pin0.read_analog() returns an integer. Program micro:bit to display the value returned by this function using the function display.scroll() every 100 ms. Turn the knob to find what is the range of values that pin0.read_analog() can return. Can you display the value every 100 ms ? 1.2. Use the function displayPositiveNumber(n) defined this morning to display the position of the knob every 100 ms. Remember that this function works well only for arguments in [0-25], so you'll need to do some scaling in between. 1.3. (Optional) If you are not comfortable with linear mapping (rescaling in our case), you could later take the time to define a function to do that for you so that map(n, n_min,n_max,res_min,res_max) = res_min + n.(res_max-res_min)/(n_max-n_min) . Solution exercice 1.1 The value returned by read_analog() is not in any physical unit. It's just a number encoded in 10 bits, meaning that it's value can go theoretically from 0 to 1024. However, this corresponds to the measure of a voltage on pin0 that can go from 0 to 3.3V (and should never go above 3.3V !). While there exist many kinds of sensors, many of them work in a similar fashion as the potentiometer. A sensor will often require a power source (3.3Volts and ground), and it will output a signal.","title":"Adding a simple sensor"},{"location":"gpio/#controlling-a-motor","text":"Now that the micro:bit can sense, you will learn how to make it act on its environment with a motor. For this get one of the motors out of the bit:buggy kit. Notice that the motor comes with its cable. Power off the micro:bit by disconnecting it from the computer , then plug the motor as shown in the image below (connection on pin1, taking care of putting the brown/black wire facing the letter G). To make the rotation of the motor more noticeable, you can take one of the white plastic end that comes in the bag where you found the motor. This piece is called a servo horn and allow for easy mechanical constructions with the motor. Figure: Connecting the servo motor to the micro:bit. There are many kinds of motor. We will come back to this later. The one you'll use now is called a continuous servo motor. While the way it works will likely seem a bit obscure, it is a great choice to start with as it is very easy to control as they require no extra components. If you are just interested in making the motor turn, skip this paragraph. For the others, here is a little theory: Servo motors are controlled using pulse width modulation (PWM). PWMs are signals made out of regular high voltage pulses with varying width. The motor will measure the width of the pulses and will turn depending on it. In our case, to control the servo motor, we need to send a high pulse every 10 milliseconds. The width of the pulse needs to be 5% to 25% the period of the pulse (0.5ms to 2.5ms long) to be taken into account by the motor. More about PWMs here and to more about continuous servo motors here . Practically, to control the motor you will need to have pin1 output a high pulse with a 10 ms period. As the documentation explains, to do so we can use the instruction pin1.set_analog_period(10) . To change its speed you will have to use the function pin1.write_analog(d) with d in [50-250]. Exercice 2 2.1. Program the micro:bit to make the robot turn. Try different values for d to make it turn at different speeds. What argument do you need to give to the write_analog() function to make the motor stop ? Does the function pin1.set_analog_period(10) need to be in the loop ? 2.2. Program the micro:bit so that you can control the speed of the motor by turning the potentiometer. Notice that the motor is quite similar to the potentiometer in terms of wiring: it needs a power supply (3.3V and ground) and a signal, except that this time the signal is going from the micro:bit to the motor. This applies to many actuators.","title":"Controlling a motor"},{"location":"gpio/#measuring-a-distance","text":"The last component you will learn to interface today is the HC-SR04. The HC-SR04, while it is commonly called an \"ultrasonic distance sensor\" is both a sensor and an actuator. It sends an ultrasound signal when the controllers orders it to do so and it informs the controller when it receives an echo. Thanks to the time between emission and reception and a bit of physics ( distance = time * velocity ) we can estimate the distance of obstacles facing the sensor. Do the montage shown in the pictures below. Add the batteries only once you double checked the montage . This montage is more complex than the previous ones and here is why: The HC-SR04 needs about 5V of power and by adding the batteries the V pins of the buggy board go up from 3.3V to about 5V (more 3x1.5V in reality). The HC-SR04 sends an echo of 5V which if plugged directly to micro:bit could burn it. The montage with the potentiometer set at its mid-position allows to solve this problem 1 . Potentiometer at its mid-position Montage Circuit diagram Figure: Using the HC-SR04 with the micro:bit: set the potentiometer to its mid-position, do the wiring. One way to use the HC-SR04 in our program is to use the following function: from microbit import * import machine import utime pinTrig = pin0 pinEcho = pin1 def get_dist_in_cm(): # send a high pulse to the trigger of HC-SR04 pinTrig.write_digital(0) utime.sleep_us(2) pinTrig.write_digital(1) utime.sleep_us(10) pinTrig.write_digital(0) # measure the time in microseconds that it takes to receive a high pulse on the echo pin. d = machine.time_pulse_us(pinEcho,1,10000)# timeout in 10000 us = 0.01 s if d>0:# echo received return d/Constant else:# timeout returns -1 return d Exercice 3 3.1. Read the code to verify if it matches the sensor specifications that we defined previously. Will this work if I call the function get_dist_in_cm() ? 3.2. It won't work ! There is something missing: Constant is not defined and that's because I want you to find it now using the laws of physics. 3.3. Once you found the value of Constant , write a program to display the distance on the LED matrix using the function displayPositiveNumber(n) . Don't forget to turn the switch of the buggy board on to test your program. When the switch is on you can actually unplug the usb cable and the circuit should continue working without the computer.","title":"Measuring a distance"},{"location":"gpio/#disco-light-optional","text":"If you finish the exercises in advance or if you are not tired enough and you want to learn more, one more thing you could do is to use the special extension board of the buggy, and learn to control it. It comes with 2 neopixel LEDs which can be controlled thanks to the neopixel library. For instance, if the board is plugged on pin0, a simple program to light up one LED in green and one in blue would be the following: from microbit import * import neopixel np = neopixel.NeoPixel(pin0, 2) np[0] = (0, 255, 0) np[1] = (0, 0, 255) np.show() Exercice 4 Connect the neopixel and the potentiometer to the micro.bit. Program the micro:bit to select the channel (R, G or B) of the first and second LED with respectively the button A and B so that you can set the value of each channel using the potentiometer.","title":"Disco light (optional)"},{"location":"gpio/#conclusion","text":"That's it for today. Turn the buggy mainboard off using it's switch to save the batteries for the coming days and unplug everything putting all the components back to their respective boxes. With what you've learned today, you've got all the electronics tools you need to make an autonomous robot. While this morning you learned to interact with the controller of a robot, now you know how to give it eyes and muscles. Moreover while your familiarity with the use of functions is growing, reusing the work we did today will get easier and easier. The the function displayPositiveNumber(n) made our work easier this afternoon to get a quick feedback from our sensors. All the work we did with the motor and the distance sensor this afternoon will make our work easier in the coming days. Talking about ease: this afternoon we dabbled in the world of electronics. This can be intimidating at first. But like most other domains, by repetitive explorations out of your confort zone, you make your confort zone wider and soon this field can be yours to play with. For now, time to rest and see you tomorrow for some more challenges ! While we use the potentiometer as a sensor it is essentially a voltage divider. Therefore we can use it to lower the voltage of the echo signal down. The way we used it as a sensor was to connect it with 3.3V and the ground, and it outputed a portion of 3.3V depending on the position of the knob, which is what we measured with the micro:bit. Instead, we can now feed it with the 0 to 5V echo signal coming from the HC-SR04, and make it output a portion of that, making sure it does not go over 3.3V. Also we need to take a large enough portion of the signal, for instance imagine we outputed 0% of the signal with the potentiometer, then we would not be able to understand when the echo is received on the micro:bit. To get it to work we need the high value of the signal to be 2.3 Volt minimum (2.3 = 0.7 * 3.3... see here for more information). Therefore if we put the knob at its mid position, it should output a signal oscillating in between 0 and 2.5V and it should work. \u21a9","title":"Conclusion"},{"location":"index_hidden/","text":"Welcome This website is intended to provide the ressources for the students following the micro:bit mobile robotics summerschool. But those ressources have been produced to be reusable, and teachers are of course welcomed to go through this site and take whatever they like for their own courses. Overall, the program of the summerschool will be as follows: The structure of this site follows the chronology of the activities you will go through (before and) during the week of the summerschool: Introduction to python As most of the activities will include some python programming, I'll need everyone to come with a minimum of experience of this langage so that we can go through all the activities without leaving anyone behind. This is the purpose of this page which will make you practice the basics of python and discover the different tools you'll need during the week if you don't know them already. Micro:bit board On monday you will discover the micro:bit controller which will be the brain of our mobile robots. You'll use your (freshly gained) skills in python to already start interacting with the board. In the afternoon, you'll start to discover how to connect a controller to sensors and actuators , that is how to give him more the ability to sense and act on its environment. Robotics and moving While previously we were limited to a bunch of components lyind around next to each other, on tuesday wou'll add a bit of structure to all this. You'll put together a simple mobile robot kit and learn to control it. In the afternoon, you'll work on the same theme, but learning to gain autonomy to decompose and solve robotics problems without guidance. Designing and building The robot we find in kits is rarelly able to satisfies all our desires. To free us from those limitations, we'll see how to design our own robot frame and build it using simple equipment first, in the morning, then using professional equipment and CAD in the afternoon. Closing and opening In the last day we'll come back on what we learned and produced during the week and you will be presented different options to contiune your exploration of mobile robotics smoothly in autonnomy. Have a good time and may you learn a lot !","title":"Welcome"},{"location":"index_hidden/#welcome","text":"This website is intended to provide the ressources for the students following the micro:bit mobile robotics summerschool. But those ressources have been produced to be reusable, and teachers are of course welcomed to go through this site and take whatever they like for their own courses. Overall, the program of the summerschool will be as follows: The structure of this site follows the chronology of the activities you will go through (before and) during the week of the summerschool: Introduction to python As most of the activities will include some python programming, I'll need everyone to come with a minimum of experience of this langage so that we can go through all the activities without leaving anyone behind. This is the purpose of this page which will make you practice the basics of python and discover the different tools you'll need during the week if you don't know them already. Micro:bit board On monday you will discover the micro:bit controller which will be the brain of our mobile robots. You'll use your (freshly gained) skills in python to already start interacting with the board. In the afternoon, you'll start to discover how to connect a controller to sensors and actuators , that is how to give him more the ability to sense and act on its environment. Robotics and moving While previously we were limited to a bunch of components lyind around next to each other, on tuesday wou'll add a bit of structure to all this. You'll put together a simple mobile robot kit and learn to control it. In the afternoon, you'll work on the same theme, but learning to gain autonomy to decompose and solve robotics problems without guidance. Designing and building The robot we find in kits is rarelly able to satisfies all our desires. To free us from those limitations, we'll see how to design our own robot frame and build it using simple equipment first, in the morning, then using professional equipment and CAD in the afternoon. Closing and opening In the last day we'll come back on what we learned and produced during the week and you will be presented different options to contiune your exploration of mobile robotics smoothly in autonnomy. Have a good time and may you learn a lot !","title":"Welcome"},{"location":"microbit/","text":"Introduction to micro:bit This morning, you will discover what will be the brain of the mobile robot you will build: the micro:bit. You'll see that this controller comes already out of the box with sensors and actuators, which are the building blocks of a robot, and you'll learn how to interact with them. What you will need Every pair of learners will need: A computer equipped with a connection to internet and a browser (ideally Chrome) One micro:bit A usb cable to connect the micro:bit to the computer. Programming Micro:bit Gather all the material listed above and connect the micro:bit to the computer. You should see an external drive appear on your computer called MICROBIT . To program the micro:bit you will need an editor. For this open the Python online editor for micro:bit on your web browser. On this page you'll be facing with a big black area with some python code. This area is the editor where you'll type your programs. On top of that you should see different buttons/icons that will allow you to interact with your computer, and the micro:bit directly if you are using Chrome. When you open the editor, it comes with an \"Hello, World!\" example. To start, you have to learn to transfer a program onto the micro:bit. For that: First option: you click the Download button. This will download the program as an .hex file named microbit_program.hex on your computer. To put it in the micro:bit, drag and drop the .hex to the MICROBIT external drive. Second and easiest option if you have chrome: click Connect , select the micro:bit in the menu and click again on connect, and now the Download button should have transformed into a Flash button. This button allows you to directly put (flash) the program from the web-browser to the micro:bit. At the end of both options, an orange LED should blink on the micro:bit, informing you about the transmission. When the transfer is over the program should start automatically and you should see the execution of the program on the red LEDs of the micro:bit. Congratulation, you gave your first program to the micro:bit ! Micro:bit specific functions The structure of a program on a microcontroller is and will almost always be as follow: first, an initialisation , then a loop . Take the time to identify those two parts in the previous program. Here is another program to show you some specific micro:bit functions that are available to use its buttons ( button_a.was_pressed() ) and its LED matrix ( display.set_pixel() and display.clear() ): # Initialisation # Get standard librairies from microbit import * # Loop while True: if button_a.was_pressed(): display.set_pixel(0,2,9) sleep(1000) display.clear() if button_b.was_pressed(): display.set_pixel(4,2,9) sleep(1000) display.clear() sleep(100) Exercice 1 1.1 Flash the micro:bit with this program. What do the the arguments of the functions set_pixel() and sleep() correspond to ? To answer either try to change the program or read the do ( sleep doc , display doc ) or even better, do both. 1.2 Execute the instruction display.set_pixel(-1,2,9) in your program and see what happens. Solution exercise 1.2 Normally you should see the error \"Line ... valueError index out of bounds\". That's what will happen if you ask the micro:bit to do something it cannot do. It will tell you the exact line where you shoud look to solve you problem , and why (in this case the first argument of set_pixel can only accept values from 0 to 4). With experience, most of the time, only the line number will be enough for you to correct your mistake. Your first program displayPositiveNumber(0) displayPositiveNumber(1) displayPositiveNumber(2) displayPositiveNumber(5) Figure: A program to display rapidely the value of a variable from 0 to 5. In the previous exercise you learned to interact with some basic functions of micro:bit. It is now time to bring your knowledge of python into play to interact with those. By reinvesting your knowledge of variables, conditions, loops and functions you will define a function that will help us work with micro:bit all through the week. The functions display.show() and display.scroll() are powerful and can show many types of variables (integers, floats, strings) on the screen of the micro:bit. Such functions are useful to debug in showing us some valuable information. However, as we saw with the \"Hello, World!\" example, this function is also not very reactive, while we need to be reactive in robotics. We can not wait 2 seconds for each piece of information. So you will define a function which will solve this problem. Exercice 2 2.1. Define an integer variable x , initialise it to 0 and display its value every 100 ms using display.scroll() . 2.2. Program the micro:bit so that you can use the buttons A and B to increase and decrease the value of x . What happens if x > 9 , can you show x value every 100 ms ? 2.3. Forget about the value of x for this sub-exercise. Replace the line that was displaying the value of x and instead, use a for i in range(4): ... loop and the function display.set_pixel() to light up the first line of LEDs. 2.4. Modify your program to display the value of x as in the pictures above. Hint: you can either change the for loop, either add a condition. 2.5. Define a function displayPositiveNumber(n) , that shows the value of an integer n for n in [0-5] on the LED matrix. Going further displayPositiveNumber(0) displayPositiveNumber(7) displayPositiveNumber(14) displayPositiveNumber(25) If we plug some sensors to the micro:bit and we want to display some quantitative information coming from them, displayPositiveNumber(n) is exactly the sort of function we need. However, for now, our resolution is very little (only 6 possible values can be displayed). To get a richer feedback, let's use the whole LED matrix. For this you'll modify the previous function slightly: def displayPositiveNumber(d): display.clear() for i in range(d): display.set_pixel(i%5,int(i/5),9) Exercice 3 3.1. On a piece of paper, represent a 5x5 grid and set a number for each row and column, starting on the top left with the coordinate (0,0). For i = {4,5,6,24} compute i%5 (meaning i mod 5 ... meaning the rest of the integer division of i by 5) and int(i/5) (meaning the integer part of i/5). Write down the value of i in the grid at the position (i%5,int(i/5)). 3.2. Now that you should have a better understanding of this function, test it by updating the code in the previous exercise. In the end you should have a program to set the value of x using the buttons and display its value for x in [0-25] . 3.3. (Optional) The function displayPositiveNumber() is reliable only for values in [0-25]. Make it more reliable by adding a condition so that if the provided argument is not in that range, you will display something special (for instance one LED on in the middle of the LED matrix). 3.4. (Optional) There are different ways to write a function such as displayPositiveNumber(d) . Find other ways to define the function. You could for instance use nested loops (a loop in a loop) or use two counters (integer variables) and a condition (that would allows to not use modulo or the integer division). You are now equipped with a function which is going to be very useful this afternoon. To reuse it this afternoon, save it using the \"Load/Save\" button, followed by clicking the \"Download Python Script\" button. This will allow you to save it as a python file an reload it this afternoon. If you did not understand the functioning of this function, take some time to do so. Talk to the people around you if you need help. Conclusion This morning you saw one key component of what makes a robot: its controller . The controller is the brain of the robot which does the interface between its sensors and its actuators . But you saw more than that. Indeed by programming the micro:bit you already had a quick go at doing the interface between some integrated sensors (buttons) and actuators (LED matrix) of the board. While this sensors/controller/actuators design is the standard design for mobile robots, it also applies to many other fields. Look around you and you'll see this arrangement is standard in technology as well as in life. A smartphone comes with sensors: a camera, touch(screen), microphones, radio receptor, accelerometer, compas; and with actuators: a screen, speakers and radio emettor. Human beings come with sensors too, although they are harder to isolate than on machine, but making it simple we could say that most of them come equipped with eyes, ears, nose, skin, tongue and proprioceptors (too often forgotten). We also saw that for the controller to make the link between the sensors and the actuators, you need to give it a program. While you used the micro:bit this morning, what you learn applies to most other controllers: A programming language is most of the time composed of standard building blocks such as instructions, variables, conditions, loops and functions The structure of the program of a robot comes almost always with an initialisation and a loop (and sometimes with interrupts but I invite you to discover this when you are already familiar with the basics).","title":"Microbit"},{"location":"microbit/#introduction-to-microbit","text":"This morning, you will discover what will be the brain of the mobile robot you will build: the micro:bit. You'll see that this controller comes already out of the box with sensors and actuators, which are the building blocks of a robot, and you'll learn how to interact with them.","title":"Introduction to micro:bit"},{"location":"microbit/#what-you-will-need","text":"Every pair of learners will need: A computer equipped with a connection to internet and a browser (ideally Chrome) One micro:bit A usb cable to connect the micro:bit to the computer.","title":"What you will need"},{"location":"microbit/#programming-microbit","text":"Gather all the material listed above and connect the micro:bit to the computer. You should see an external drive appear on your computer called MICROBIT . To program the micro:bit you will need an editor. For this open the Python online editor for micro:bit on your web browser. On this page you'll be facing with a big black area with some python code. This area is the editor where you'll type your programs. On top of that you should see different buttons/icons that will allow you to interact with your computer, and the micro:bit directly if you are using Chrome. When you open the editor, it comes with an \"Hello, World!\" example. To start, you have to learn to transfer a program onto the micro:bit. For that: First option: you click the Download button. This will download the program as an .hex file named microbit_program.hex on your computer. To put it in the micro:bit, drag and drop the .hex to the MICROBIT external drive. Second and easiest option if you have chrome: click Connect , select the micro:bit in the menu and click again on connect, and now the Download button should have transformed into a Flash button. This button allows you to directly put (flash) the program from the web-browser to the micro:bit. At the end of both options, an orange LED should blink on the micro:bit, informing you about the transmission. When the transfer is over the program should start automatically and you should see the execution of the program on the red LEDs of the micro:bit. Congratulation, you gave your first program to the micro:bit !","title":"Programming Micro:bit"},{"location":"microbit/#microbit-specific-functions","text":"The structure of a program on a microcontroller is and will almost always be as follow: first, an initialisation , then a loop . Take the time to identify those two parts in the previous program. Here is another program to show you some specific micro:bit functions that are available to use its buttons ( button_a.was_pressed() ) and its LED matrix ( display.set_pixel() and display.clear() ): # Initialisation # Get standard librairies from microbit import * # Loop while True: if button_a.was_pressed(): display.set_pixel(0,2,9) sleep(1000) display.clear() if button_b.was_pressed(): display.set_pixel(4,2,9) sleep(1000) display.clear() sleep(100) Exercice 1 1.1 Flash the micro:bit with this program. What do the the arguments of the functions set_pixel() and sleep() correspond to ? To answer either try to change the program or read the do ( sleep doc , display doc ) or even better, do both. 1.2 Execute the instruction display.set_pixel(-1,2,9) in your program and see what happens. Solution exercise 1.2 Normally you should see the error \"Line ... valueError index out of bounds\". That's what will happen if you ask the micro:bit to do something it cannot do. It will tell you the exact line where you shoud look to solve you problem , and why (in this case the first argument of set_pixel can only accept values from 0 to 4). With experience, most of the time, only the line number will be enough for you to correct your mistake.","title":"Micro:bit specific functions"},{"location":"microbit/#your-first-program","text":"displayPositiveNumber(0) displayPositiveNumber(1) displayPositiveNumber(2) displayPositiveNumber(5) Figure: A program to display rapidely the value of a variable from 0 to 5. In the previous exercise you learned to interact with some basic functions of micro:bit. It is now time to bring your knowledge of python into play to interact with those. By reinvesting your knowledge of variables, conditions, loops and functions you will define a function that will help us work with micro:bit all through the week. The functions display.show() and display.scroll() are powerful and can show many types of variables (integers, floats, strings) on the screen of the micro:bit. Such functions are useful to debug in showing us some valuable information. However, as we saw with the \"Hello, World!\" example, this function is also not very reactive, while we need to be reactive in robotics. We can not wait 2 seconds for each piece of information. So you will define a function which will solve this problem. Exercice 2 2.1. Define an integer variable x , initialise it to 0 and display its value every 100 ms using display.scroll() . 2.2. Program the micro:bit so that you can use the buttons A and B to increase and decrease the value of x . What happens if x > 9 , can you show x value every 100 ms ? 2.3. Forget about the value of x for this sub-exercise. Replace the line that was displaying the value of x and instead, use a for i in range(4): ... loop and the function display.set_pixel() to light up the first line of LEDs. 2.4. Modify your program to display the value of x as in the pictures above. Hint: you can either change the for loop, either add a condition. 2.5. Define a function displayPositiveNumber(n) , that shows the value of an integer n for n in [0-5] on the LED matrix.","title":"Your first program"},{"location":"microbit/#going-further","text":"displayPositiveNumber(0) displayPositiveNumber(7) displayPositiveNumber(14) displayPositiveNumber(25) If we plug some sensors to the micro:bit and we want to display some quantitative information coming from them, displayPositiveNumber(n) is exactly the sort of function we need. However, for now, our resolution is very little (only 6 possible values can be displayed). To get a richer feedback, let's use the whole LED matrix. For this you'll modify the previous function slightly: def displayPositiveNumber(d): display.clear() for i in range(d): display.set_pixel(i%5,int(i/5),9) Exercice 3 3.1. On a piece of paper, represent a 5x5 grid and set a number for each row and column, starting on the top left with the coordinate (0,0). For i = {4,5,6,24} compute i%5 (meaning i mod 5 ... meaning the rest of the integer division of i by 5) and int(i/5) (meaning the integer part of i/5). Write down the value of i in the grid at the position (i%5,int(i/5)). 3.2. Now that you should have a better understanding of this function, test it by updating the code in the previous exercise. In the end you should have a program to set the value of x using the buttons and display its value for x in [0-25] . 3.3. (Optional) The function displayPositiveNumber() is reliable only for values in [0-25]. Make it more reliable by adding a condition so that if the provided argument is not in that range, you will display something special (for instance one LED on in the middle of the LED matrix). 3.4. (Optional) There are different ways to write a function such as displayPositiveNumber(d) . Find other ways to define the function. You could for instance use nested loops (a loop in a loop) or use two counters (integer variables) and a condition (that would allows to not use modulo or the integer division). You are now equipped with a function which is going to be very useful this afternoon. To reuse it this afternoon, save it using the \"Load/Save\" button, followed by clicking the \"Download Python Script\" button. This will allow you to save it as a python file an reload it this afternoon. If you did not understand the functioning of this function, take some time to do so. Talk to the people around you if you need help.","title":"Going further"},{"location":"microbit/#conclusion","text":"This morning you saw one key component of what makes a robot: its controller . The controller is the brain of the robot which does the interface between its sensors and its actuators . But you saw more than that. Indeed by programming the micro:bit you already had a quick go at doing the interface between some integrated sensors (buttons) and actuators (LED matrix) of the board. While this sensors/controller/actuators design is the standard design for mobile robots, it also applies to many other fields. Look around you and you'll see this arrangement is standard in technology as well as in life. A smartphone comes with sensors: a camera, touch(screen), microphones, radio receptor, accelerometer, compas; and with actuators: a screen, speakers and radio emettor. Human beings come with sensors too, although they are harder to isolate than on machine, but making it simple we could say that most of them come equipped with eyes, ears, nose, skin, tongue and proprioceptors (too often forgotten). We also saw that for the controller to make the link between the sensors and the actuators, you need to give it a program. While you used the micro:bit this morning, what you learn applies to most other controllers: A programming language is most of the time composed of standard building blocks such as instructions, variables, conditions, loops and functions The structure of the program of a robot comes almost always with an initialisation and a loop (and sometimes with interrupts but I invite you to discover this when you are already familiar with the basics).","title":"Conclusion"},{"location":"python/","text":"Introduction to Python During the upcoming robotics summerschool, I'll need you to be confortable with the basics of python programming. I wrote this page using embedded codes to have everyone starting with the bare minimum going from a simple \"Hello world\" script to using variables, loops, conditions and functions. As the program of the summerschool will be intense, I'll need most of you to be confortable with those. Comments and simple instructions For each section of this page I'll use embedded code that allow you to run python scripts without leaving this page, and interact with the code as you wish. So let's go: read the code, try to predict what's going to happen in the terminal (in black), and press the pay button. Again, don't hesitate to change the code and press play again to try things out, anything ! For that you can also directly type instructions in the terminal (the black window). Variables and standard operations Computers are so useful to us because they don't always to the same things over and over. It's the same with mobile robots, they can adapt to their environment. This would be impossible to do without taking into account some variations in our programs. To deal with those variations, we use what we call variables. A variable is like a box where we put some information that can vary during the execution of a program. Same here, change the code, make it crash ! (Even more than it already does !) Loops Another way computers and robots change our lives is in their ability to cope with repetitive task without being bored. But the programmer who programmed them gets easily bored, so he needs to have a tool to take care of repetitions in is code. That's what loops are for. Exercice 1 Add some lines in the script above to display the 20 first numbers of the Fibonacci sequence. Solution exercice 1 Functions Do you know what assembly language is ? Take a few seconds to have a look at it on wikipedia and try to decipher what the program in the top right image does... That's not the language you want to program in every day ! Take some time to contemplate the chance you have to not go through that and instead use python. Well, you have this chance partly thanks to functions. As in mathematics, functions can take arguments and return a value. You should have all by now used the cosine function. Cosine takes onoe parameter, an angle, and returns a value in between -1 and 1. In computer science, functions come in many forms. They can take argumet(s) or not. They can return values but they don't have to (in this case we could call it a procedure). Such a tool allow to make our code readable, less repetitive, and combine and build functions with and on one another. That's how, thanks to programmers, your computer can understand some high level langage like python, while at its core it can only understand assembly. Let's see how to use this incredible tool on python. Exercice 2 Define a function with one parameter n that compute and return the golden ratio using the fibonacci n th and n+1 th numbers. Solution exercice 2 See how simple the exercise is if we use the predefined fibonacci function. The exercise would have been much harder if we had to start from scratch. Conditions In our programs, depending on some variables, sometimes we want to do things, sometimes we don't. To perform such a feat the last ingredient we are missing in our arsenal of tools are conditions. Conditions are quite simple and we use them everyday: Does it rain ? Yes/No => Take an umbrella/Don't. Note that in computer science, conditions are made of: a test resulting in a boolean (True or False), what to do if the test is True, and sometimes what to do if it is not. Exercice 3 Modify the code following the instructions inside it. Solution exercice 3 Conclusion That's all for now. Thanks for going through this introduction and I see you soon to use those new skills of yours to discover the world of mobile robotics.","title":"Introduction to Python"},{"location":"python/#introduction-to-python","text":"During the upcoming robotics summerschool, I'll need you to be confortable with the basics of python programming. I wrote this page using embedded codes to have everyone starting with the bare minimum going from a simple \"Hello world\" script to using variables, loops, conditions and functions. As the program of the summerschool will be intense, I'll need most of you to be confortable with those.","title":"Introduction to Python"},{"location":"python/#comments-and-simple-instructions","text":"For each section of this page I'll use embedded code that allow you to run python scripts without leaving this page, and interact with the code as you wish. So let's go: read the code, try to predict what's going to happen in the terminal (in black), and press the pay button. Again, don't hesitate to change the code and press play again to try things out, anything ! For that you can also directly type instructions in the terminal (the black window).","title":"Comments and simple instructions"},{"location":"python/#variables-and-standard-operations","text":"Computers are so useful to us because they don't always to the same things over and over. It's the same with mobile robots, they can adapt to their environment. This would be impossible to do without taking into account some variations in our programs. To deal with those variations, we use what we call variables. A variable is like a box where we put some information that can vary during the execution of a program. Same here, change the code, make it crash ! (Even more than it already does !)","title":"Variables and standard operations"},{"location":"python/#loops","text":"Another way computers and robots change our lives is in their ability to cope with repetitive task without being bored. But the programmer who programmed them gets easily bored, so he needs to have a tool to take care of repetitions in is code. That's what loops are for. Exercice 1 Add some lines in the script above to display the 20 first numbers of the Fibonacci sequence. Solution exercice 1","title":"Loops"},{"location":"python/#functions","text":"Do you know what assembly language is ? Take a few seconds to have a look at it on wikipedia and try to decipher what the program in the top right image does... That's not the language you want to program in every day ! Take some time to contemplate the chance you have to not go through that and instead use python. Well, you have this chance partly thanks to functions. As in mathematics, functions can take arguments and return a value. You should have all by now used the cosine function. Cosine takes onoe parameter, an angle, and returns a value in between -1 and 1. In computer science, functions come in many forms. They can take argumet(s) or not. They can return values but they don't have to (in this case we could call it a procedure). Such a tool allow to make our code readable, less repetitive, and combine and build functions with and on one another. That's how, thanks to programmers, your computer can understand some high level langage like python, while at its core it can only understand assembly. Let's see how to use this incredible tool on python. Exercice 2 Define a function with one parameter n that compute and return the golden ratio using the fibonacci n th and n+1 th numbers. Solution exercice 2 See how simple the exercise is if we use the predefined fibonacci function. The exercise would have been much harder if we had to start from scratch.","title":"Functions"},{"location":"python/#conditions","text":"In our programs, depending on some variables, sometimes we want to do things, sometimes we don't. To perform such a feat the last ingredient we are missing in our arsenal of tools are conditions. Conditions are quite simple and we use them everyday: Does it rain ? Yes/No => Take an umbrella/Don't. Note that in computer science, conditions are made of: a test resulting in a boolean (True or False), what to do if the test is True, and sometimes what to do if it is not. Exercice 3 Modify the code following the instructions inside it. Solution exercice 3","title":"Conditions"},{"location":"python/#conclusion","text":"That's all for now. Thanks for going through this introduction and I see you soon to use those new skills of yours to discover the world of mobile robotics.","title":"Conclusion"},{"location":"radio/","text":"Engineering - Remote controlling Before building a mobile robot such as the one we build this morning, an engineer is likely to first study what controller he can pick, choose one and test it. Once this is done, he might study the available motors, choose one type of motor, and make sure he's able to control them. Only once he mastered every individual elements will he put them together. Problem decomposition is a key skill for every engineer. In the previous activities, the problems to solve have always been decomposed in simpler problems for you to advance safely in them in a similar fashion. Indeed this is standard in pedagogy too. Therefore, you have already been exposed to this process a lot. This afternoon's goal is to make you practice doing this problem decomposition yourself. What you will need The material is the same as this mornig's material, except for the cardboard which is not needed. However , as we'll make two micro:bits interact, you will have to be at least two pairs (with one micro:bit each) and to organise yourselves among pairs. Remote controlled buggy The problem you will practice your problem decomposition skill on will consist in programming a remote controlled buggy: the remote control (or joystick) will be a micro:bit, which will send its commands to the buggy through radio waves. Exercice Define the milestones that you and your team will have to reach to eventually have the whole problem solved. In other words, find many smaller problems to solve that will help you solve the bigger problem at hand. As you will need to have two micro:bit to do your experiments, your team will have to be composed of at least two pairs of learners. The documentation of the radio emittor and receptor of the micro:bit can be found here . Solution After some time, we will provide you with a proposition of milestones. More projects If you managed to program the micro:bit as asked in the previous project, here are some more ideas you can work on to develop your engineering skills: Project 1 (incremental): Control the buggy using another micro:bit equipped with two potentiometers (remove the batteries if you do so to make sure you don't give 5V to micro:bit and burn it). One potentiometer for the forward/backward speed, the other for turning (like on many RC vehicles) Project 2 (hard): Program the buggy to always come back to the orientation it started with. For this you'll need to use it's internal compas which is quite a special sensor. Conclusion This afternoon you focused on problem decomposition. This strategy is not only usefull in engineering but in many, many other fields. As a sportsman , if you want to learn a new move, if you have the chance to have a coach, he will help you break down this new move in simpler moves. If you don't have a coach then you will increase you chances to do the move right in decomposing it in simpler movements and pratice them individually. As a musician , before learning to play a tune, you will benefit in learning to play scales beforehand, as boring as it might seem. While it is easy to disregard such practices as boring, we should not forget their power: the smaller problems we solved or the simple skills we develop are often at the fundation of many other bigger problems or skills. Once we mastered one scale, it is not one tune that we can play with more ease but all the other tunes in this scale. And the same applies for problem solving in engineering.","title":"Radio"},{"location":"radio/#engineering-remote-controlling","text":"Before building a mobile robot such as the one we build this morning, an engineer is likely to first study what controller he can pick, choose one and test it. Once this is done, he might study the available motors, choose one type of motor, and make sure he's able to control them. Only once he mastered every individual elements will he put them together. Problem decomposition is a key skill for every engineer. In the previous activities, the problems to solve have always been decomposed in simpler problems for you to advance safely in them in a similar fashion. Indeed this is standard in pedagogy too. Therefore, you have already been exposed to this process a lot. This afternoon's goal is to make you practice doing this problem decomposition yourself.","title":"Engineering - Remote controlling"},{"location":"radio/#what-you-will-need","text":"The material is the same as this mornig's material, except for the cardboard which is not needed. However , as we'll make two micro:bits interact, you will have to be at least two pairs (with one micro:bit each) and to organise yourselves among pairs.","title":"What you will need"},{"location":"radio/#remote-controlled-buggy","text":"The problem you will practice your problem decomposition skill on will consist in programming a remote controlled buggy: the remote control (or joystick) will be a micro:bit, which will send its commands to the buggy through radio waves. Exercice Define the milestones that you and your team will have to reach to eventually have the whole problem solved. In other words, find many smaller problems to solve that will help you solve the bigger problem at hand. As you will need to have two micro:bit to do your experiments, your team will have to be composed of at least two pairs of learners. The documentation of the radio emittor and receptor of the micro:bit can be found here . Solution After some time, we will provide you with a proposition of milestones.","title":"Remote controlled buggy"},{"location":"radio/#more-projects","text":"If you managed to program the micro:bit as asked in the previous project, here are some more ideas you can work on to develop your engineering skills: Project 1 (incremental): Control the buggy using another micro:bit equipped with two potentiometers (remove the batteries if you do so to make sure you don't give 5V to micro:bit and burn it). One potentiometer for the forward/backward speed, the other for turning (like on many RC vehicles) Project 2 (hard): Program the buggy to always come back to the orientation it started with. For this you'll need to use it's internal compas which is quite a special sensor.","title":"More projects"},{"location":"radio/#conclusion","text":"This afternoon you focused on problem decomposition. This strategy is not only usefull in engineering but in many, many other fields. As a sportsman , if you want to learn a new move, if you have the chance to have a coach, he will help you break down this new move in simpler moves. If you don't have a coach then you will increase you chances to do the move right in decomposing it in simpler movements and pratice them individually. As a musician , before learning to play a tune, you will benefit in learning to play scales beforehand, as boring as it might seem. While it is easy to disregard such practices as boring, we should not forget their power: the smaller problems we solved or the simple skills we develop are often at the fundation of many other bigger problems or skills. Once we mastered one scale, it is not one tune that we can play with more ease but all the other tunes in this scale. And the same applies for problem solving in engineering.","title":"Conclusion"},{"location":"robot/","text":"Mobile robotics - Control systems Yesterday, you learned how to make a robot sense and how to make it act on its environment. But there was a big things missing to make the robot really move: a frame, a structure to hold all the parts together, we could say the bones of our mobile robot. Today we'll solve this problem: you'll build a frame, and thanks to this frame you will discover some standard mobile robotics problems and learn how to solve them. What you will need Every pair of learners will need: A computer equipped with a connection to internet and a browser (ideally Chrome), One micro:bit, A usb cable to connect the micro:bit to the computer, One bit:buggy kit, A flat piece of cardboard. Building the big:buggy Read the manual Collect the parts Building Done Figure: Building the bit:buggy. To build the robot, I invite you to follow the instructions provided in the Bit:Buggy isntruction manual. However this manual is missing some valuable information: Before starting identify the two bags that come along with the servo motors (in them there should screws and several servo horns, that is white plastic pieces to put on the servos). Those pieces won't be of any use and are not listed in the component list of the bit:buggy car, so put them aside. In step 1. pay attention to the wheels: their two sides are differents, only one side can plug onto the motor end. Also, when screwing the wheel onto the motor, hold the wheel (if you don't you could make the motor turn using the screws and that might damage the motor). In step 3. make the cables of the motors stick upward. Moreover you have to push through to really get the plastic parts completely in one another. In step 4. be delicate with the screw. You should not have to force. If it's hard to screw it in, it's probably that the alignment is ot correct. If it is, unscrew first, correct the alignment and try screwing again. Before step 6 put the batteries in if it is not yet in, and turn off the board with the switch. After step 6, when you plug the cables, remember you learned today: the black cable plugs onto G ! The picture of the instructions might be a bit misleading. By the way the cables are long (not like the picture), simply tuck them inside the robot frame and you are ready to roll. Moving basics The robot has now some bones to hold together its muscles, eyes and brain, it's time for you to remember what you learned yesterday to do a simple program to make it move. Exercice 1 1.1 Program micro:bit to move forward when the button A is pressed and stop when B is pressed. 1.2 Rewrite your program to make it clean and reusable: define the functions setLeftSpeed(v) and setRightSpeed(v) for v in [-100, 100] so that to go straight at full speed we just have to call setLeftSpeed(100) and setRightSpeed(100) . 1.3 Rewrite your program to make it even cleaner and reusable: define a function goStraight(v) that can be used to make the robot move forward ( v > 0 ) or backward ( v < 0 ) at the speed you want. Control systems Open-loop and closed-loop systems Figure: Closed-loop system of an heater AC. In engineering there are two types of control systems. The first one is the open-loop system, also known as non-feedback system. It is the kind of systems that we used in the previous exercises: the outputs of those systems do not produce changes on thier inputs. Here is an analogy with an air conditioner/heater: an open loop system in this case would be a system with three buttons, heat, cool down and stop, and the user would have to press the button whenever he wishes the machine to do something different. The second type of control system is the closed-loop one. In this one, there is a feedback, from the outputs to the inputs. Coming back to the aircond/heater example, to use the previous machine in a closed-loop system, you'd have to equip it with a temperature sensor and a controller. One way to use such a system, could be to program the controller to activate the heater if the measured temperature is below a given value and activate the air conditioner if the temperature is above it. That's what many of us have in our houses (without the air conditioner). In that case, the action of the heater would influence the temperature and therefore its measure. There is a feedback from the actuator of the machine to its input. On/off clontrol law on the buggy In this activity, you will learn how to program a closed-loop system using two different control laws. To do so you will use one more sensor which is integrated in the micro:bit that you did not use yet: its accelerometer. You will put the buggy on a slope and you will need to use a closed-control loop to avoid it flipping on the side. To know if the buggy is about to flip, you will need to look into the information that the accelerometer gives. Question Using the documentation of the accelerometer here find which of its axis informs us about the sideway (roll) inclination of the buggy. Depending on this information, we can program the robot to turn left or right to face towards the top of the slope as presented in the figure below. Notice the feedback loop: turning has a direct effect on the roll and, as a result on the measure of the accelerometer. Roll Roll Figure: The buggy moves along the steepest ascent. Exercise 2 2.1. Using display.scroll() , display the measure of the acceleration along the chosen axis. Tilt the buggy by holding it in your hands. What are the minimum values returned by the function accelerometer.get_.() ? What physical measure does that corresponds to ? 2.2. In the loop of the controller, define a variable error in which you will store the error between the desired acceleration along the chosen axis and its actual measure. 2.3. Program the buggy to move as described in the image above so that if the roll is over a certain threshold it turns towards the slope (which will reduce its roll). Test your program by putting the buggy on a piece of cardboard so that you can change the slope. Propotional control law on the buggy On/Off Proportional Figure: Evolution of the error with respect to time for both control laws. Coming back to our heating analogy, the previous control law would correspond to this: the user set a desired temperature or temperature range which is acceptable, if the measured temperature is lower than this the heating will be activated automatically, if the temperature is higher the air conditioning will be activated. The problem with such a strategy (called an on/off control law) is that if the temperature is much lower than what is acceptable, if we could, we would prefer the heater to work much harder than if we were close to the desired temperature. This alternative is called a proportional control law. As we are able to control how fast our robot turns, it is possible to set the turning speed so that the more the robot is tilted on the side, the faster it will turn. Exercice 3 3.1. Use the error defined in the previous exercise to control the turning speed of the robot using a proportional control law. Test your program. 3.2. (Optional) Change you program slighly so that when the buggy is flat it stops and when ts pitch increases it goes forward faster and faster. 3.3. (Optional) Combine the exercises 3.1 and 3.2 to make the buggy move toward the top of the slope it is on. Question Is the error ever converging to zero ? If not why could that be ? Conclusion Control systems are everywhere. We have more and more robots around us because they do what we want them to do but also because they can easily make things as we want them to be, and this is thanks to control systems and control laws. While the proportional control law that you programmed this morning is a must in mobile robotics, we often need to go beyond that. As you probybly noticed, the error can not converge to zero with such a simple control law. To really make it converge to zero we need more complex laws, namely PID, standing for Proportional-Integral-Derivative . If you ever wondered why you are studying integrals and derivatives, have a look at PIDs ( here is a great ressource) and you'll find one reason to do so.","title":"Robot"},{"location":"robot/#mobile-robotics-control-systems","text":"Yesterday, you learned how to make a robot sense and how to make it act on its environment. But there was a big things missing to make the robot really move: a frame, a structure to hold all the parts together, we could say the bones of our mobile robot. Today we'll solve this problem: you'll build a frame, and thanks to this frame you will discover some standard mobile robotics problems and learn how to solve them.","title":"Mobile robotics - Control systems"},{"location":"robot/#what-you-will-need","text":"Every pair of learners will need: A computer equipped with a connection to internet and a browser (ideally Chrome), One micro:bit, A usb cable to connect the micro:bit to the computer, One bit:buggy kit, A flat piece of cardboard.","title":"What you will need"},{"location":"robot/#building-the-bigbuggy","text":"Read the manual Collect the parts Building Done Figure: Building the bit:buggy. To build the robot, I invite you to follow the instructions provided in the Bit:Buggy isntruction manual. However this manual is missing some valuable information: Before starting identify the two bags that come along with the servo motors (in them there should screws and several servo horns, that is white plastic pieces to put on the servos). Those pieces won't be of any use and are not listed in the component list of the bit:buggy car, so put them aside. In step 1. pay attention to the wheels: their two sides are differents, only one side can plug onto the motor end. Also, when screwing the wheel onto the motor, hold the wheel (if you don't you could make the motor turn using the screws and that might damage the motor). In step 3. make the cables of the motors stick upward. Moreover you have to push through to really get the plastic parts completely in one another. In step 4. be delicate with the screw. You should not have to force. If it's hard to screw it in, it's probably that the alignment is ot correct. If it is, unscrew first, correct the alignment and try screwing again. Before step 6 put the batteries in if it is not yet in, and turn off the board with the switch. After step 6, when you plug the cables, remember you learned today: the black cable plugs onto G ! The picture of the instructions might be a bit misleading. By the way the cables are long (not like the picture), simply tuck them inside the robot frame and you are ready to roll.","title":"Building the big:buggy"},{"location":"robot/#moving-basics","text":"The robot has now some bones to hold together its muscles, eyes and brain, it's time for you to remember what you learned yesterday to do a simple program to make it move. Exercice 1 1.1 Program micro:bit to move forward when the button A is pressed and stop when B is pressed. 1.2 Rewrite your program to make it clean and reusable: define the functions setLeftSpeed(v) and setRightSpeed(v) for v in [-100, 100] so that to go straight at full speed we just have to call setLeftSpeed(100) and setRightSpeed(100) . 1.3 Rewrite your program to make it even cleaner and reusable: define a function goStraight(v) that can be used to make the robot move forward ( v > 0 ) or backward ( v < 0 ) at the speed you want.","title":"Moving basics"},{"location":"robot/#control-systems","text":"","title":"Control systems"},{"location":"robot/#open-loop-and-closed-loop-systems","text":"Figure: Closed-loop system of an heater AC. In engineering there are two types of control systems. The first one is the open-loop system, also known as non-feedback system. It is the kind of systems that we used in the previous exercises: the outputs of those systems do not produce changes on thier inputs. Here is an analogy with an air conditioner/heater: an open loop system in this case would be a system with three buttons, heat, cool down and stop, and the user would have to press the button whenever he wishes the machine to do something different. The second type of control system is the closed-loop one. In this one, there is a feedback, from the outputs to the inputs. Coming back to the aircond/heater example, to use the previous machine in a closed-loop system, you'd have to equip it with a temperature sensor and a controller. One way to use such a system, could be to program the controller to activate the heater if the measured temperature is below a given value and activate the air conditioner if the temperature is above it. That's what many of us have in our houses (without the air conditioner). In that case, the action of the heater would influence the temperature and therefore its measure. There is a feedback from the actuator of the machine to its input.","title":"Open-loop and closed-loop systems"},{"location":"robot/#onoff-clontrol-law-on-the-buggy","text":"In this activity, you will learn how to program a closed-loop system using two different control laws. To do so you will use one more sensor which is integrated in the micro:bit that you did not use yet: its accelerometer. You will put the buggy on a slope and you will need to use a closed-control loop to avoid it flipping on the side. To know if the buggy is about to flip, you will need to look into the information that the accelerometer gives. Question Using the documentation of the accelerometer here find which of its axis informs us about the sideway (roll) inclination of the buggy. Depending on this information, we can program the robot to turn left or right to face towards the top of the slope as presented in the figure below. Notice the feedback loop: turning has a direct effect on the roll and, as a result on the measure of the accelerometer. Roll Roll Figure: The buggy moves along the steepest ascent. Exercise 2 2.1. Using display.scroll() , display the measure of the acceleration along the chosen axis. Tilt the buggy by holding it in your hands. What are the minimum values returned by the function accelerometer.get_.() ? What physical measure does that corresponds to ? 2.2. In the loop of the controller, define a variable error in which you will store the error between the desired acceleration along the chosen axis and its actual measure. 2.3. Program the buggy to move as described in the image above so that if the roll is over a certain threshold it turns towards the slope (which will reduce its roll). Test your program by putting the buggy on a piece of cardboard so that you can change the slope.","title":"On/off clontrol law on the buggy"},{"location":"robot/#propotional-control-law-on-the-buggy","text":"On/Off Proportional Figure: Evolution of the error with respect to time for both control laws. Coming back to our heating analogy, the previous control law would correspond to this: the user set a desired temperature or temperature range which is acceptable, if the measured temperature is lower than this the heating will be activated automatically, if the temperature is higher the air conditioning will be activated. The problem with such a strategy (called an on/off control law) is that if the temperature is much lower than what is acceptable, if we could, we would prefer the heater to work much harder than if we were close to the desired temperature. This alternative is called a proportional control law. As we are able to control how fast our robot turns, it is possible to set the turning speed so that the more the robot is tilted on the side, the faster it will turn. Exercice 3 3.1. Use the error defined in the previous exercise to control the turning speed of the robot using a proportional control law. Test your program. 3.2. (Optional) Change you program slighly so that when the buggy is flat it stops and when ts pitch increases it goes forward faster and faster. 3.3. (Optional) Combine the exercises 3.1 and 3.2 to make the buggy move toward the top of the slope it is on. Question Is the error ever converging to zero ? If not why could that be ?","title":"Propotional control law on the buggy"},{"location":"robot/#conclusion","text":"Control systems are everywhere. We have more and more robots around us because they do what we want them to do but also because they can easily make things as we want them to be, and this is thanks to control systems and control laws. While the proportional control law that you programmed this morning is a must in mobile robotics, we often need to go beyond that. As you probybly noticed, the error can not converge to zero with such a simple control law. To really make it converge to zero we need more complex laws, namely PID, standing for Proportional-Integral-Derivative . If you ever wondered why you are studying integrals and derivatives, have a look at PIDs ( here is a great ressource) and you'll find one reason to do so.","title":"Conclusion"}]}