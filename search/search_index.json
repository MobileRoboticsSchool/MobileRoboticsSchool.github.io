{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome This webpage is intended to provide the ressources for the students following the micro:bit mobile robotics summerschool. But teacher who are interested are welcomed to go through this site and take whatever they like for their own courses. The structure of this site follows the chronology of the activities you will go through (before and) during the week of the summerschool: Introduction to python As most of the activities will include some python programming, I'll need everyone to come with a minimum of experience of this langage so that we can go through all the activities without leaving anyone behind. This is the purpose of this page which will make you practice the basics of python and discover the different tools you'll need during the week if you don't know them already. Micro:bit board On monday morning you will discover the micro:bit controller which will be the brain of our mobile robots. You'll use your (freshly gained) skills in python to already start interacting with the board. Inputs and outputs On monday afternoon you'll start to discover how to connect the micro:bit to sensors and actuators, that is how to give him more the ability to sense and act on its environment. Robotics and moving While previously we were limited to a bunch of components lyind around next to each other, on tuesday wou'll add a bit of structure to all this. You'll put together a simple mobile robot kit and learn to control it. Designing and building The robot we find in kits is rarelly able to satisfies all our desires. To free us from those limitations, we'll see how to design our own robot frame and build it using simple equipment. Surprise I'll let you know about the surprise in due time ! Comme ce site est tout nouveau (comme le confinement) je n'ai pour l'instant que deux projets \u00e0 vous proposer. N'h\u00e9sitez pas \u00e0 me contacter si vous avez vu quelque chose que vous aimeriez comprendre en informatique \u00e0 travers un autre projet. Je pourrais potentiellement y travailler.","title":"Welcome"},{"location":"#welcome","text":"This webpage is intended to provide the ressources for the students following the micro:bit mobile robotics summerschool. But teacher who are interested are welcomed to go through this site and take whatever they like for their own courses. The structure of this site follows the chronology of the activities you will go through (before and) during the week of the summerschool: Introduction to python As most of the activities will include some python programming, I'll need everyone to come with a minimum of experience of this langage so that we can go through all the activities without leaving anyone behind. This is the purpose of this page which will make you practice the basics of python and discover the different tools you'll need during the week if you don't know them already. Micro:bit board On monday morning you will discover the micro:bit controller which will be the brain of our mobile robots. You'll use your (freshly gained) skills in python to already start interacting with the board. Inputs and outputs On monday afternoon you'll start to discover how to connect the micro:bit to sensors and actuators, that is how to give him more the ability to sense and act on its environment. Robotics and moving While previously we were limited to a bunch of components lyind around next to each other, on tuesday wou'll add a bit of structure to all this. You'll put together a simple mobile robot kit and learn to control it. Designing and building The robot we find in kits is rarelly able to satisfies all our desires. To free us from those limitations, we'll see how to design our own robot frame and build it using simple equipment. Surprise I'll let you know about the surprise in due time ! Comme ce site est tout nouveau (comme le confinement) je n'ai pour l'instant que deux projets \u00e0 vous proposer. N'h\u00e9sitez pas \u00e0 me contacter si vous avez vu quelque chose que vous aimeriez comprendre en informatique \u00e0 travers un autre projet. Je pourrais potentiellement y travailler.","title":"Welcome"},{"location":"about/","text":"About the author After a few years in computer science research, working on very stimulating subjects such as autonomous robotics, augmented reality, 3D reconstruction and machine learning, my pleasure to share my enthusiasm for computer science has been growing. So, from computer science research I made a smooth transition to teaching it. I enjoy computer science because it offers me an infinite source of puzzles, but it's not the only reason. I think that understanding computers and having skills in the field is paramount to understanding our world which is becoming more and more digital. So I wish for everyone to know that the computer science world is open to them. and I hope to give the keys to this world to as many people as possible in the future. Luckily I joined a wonderfull team in EPFL which has a similar goal as mine (among others). That's how I ended up co animating the Thymio mobile robotics summer school with Professor Francesco Mondada to progressively animate the whole thing. Finally COVID19 force us to search for an online format, which led me to propose a new form of summerschool based on micro:bit. Collaborators This summerschool won't be possible without the support of the Service de Promotion de l'Education of EPFL. It wouldn't have been possible without the trust that Prof. F. Mondada gave me and the opportunities he gave me coanimating, animating and tinkering in the previous editions of the summerschool. I'm also thankfull for the help of Christian Chang, Anthony Guinchard and Aditya Mehrotra, for the inspiration they gave me to integrate a makers touch and for their help in the preparation of the program, the ressources and in the animation. Contact Retrouvez les informations pour me contacter sur ma page professionnelle .","title":"Contacts"},{"location":"about/#about-the-author","text":"After a few years in computer science research, working on very stimulating subjects such as autonomous robotics, augmented reality, 3D reconstruction and machine learning, my pleasure to share my enthusiasm for computer science has been growing. So, from computer science research I made a smooth transition to teaching it. I enjoy computer science because it offers me an infinite source of puzzles, but it's not the only reason. I think that understanding computers and having skills in the field is paramount to understanding our world which is becoming more and more digital. So I wish for everyone to know that the computer science world is open to them. and I hope to give the keys to this world to as many people as possible in the future. Luckily I joined a wonderfull team in EPFL which has a similar goal as mine (among others). That's how I ended up co animating the Thymio mobile robotics summer school with Professor Francesco Mondada to progressively animate the whole thing. Finally COVID19 force us to search for an online format, which led me to propose a new form of summerschool based on micro:bit.","title":"About the author"},{"location":"about/#collaborators","text":"This summerschool won't be possible without the support of the Service de Promotion de l'Education of EPFL. It wouldn't have been possible without the trust that Prof. F. Mondada gave me and the opportunities he gave me coanimating, animating and tinkering in the previous editions of the summerschool. I'm also thankfull for the help of Christian Chang, Anthony Guinchard and Aditya Mehrotra, for the inspiration they gave me to integrate a makers touch and for their help in the preparation of the program, the ressources and in the animation.","title":"Collaborators"},{"location":"about/#contact","text":"Retrouvez les informations pour me contacter sur ma page professionnelle .","title":"Contact"},{"location":"gpio/","text":"Input and outputs This morning we saw how the micro:bit comes equipped with integrated sensors and actuators, but we can all agree that for mobile robotics it might be a bit short of muscles. This afternoon you'll see how it is possible to add sensors and actuators to the micro:bit to go toward our goal of building an autonomous mobile robot. GPIO As you might have already noticed, on the bottom of the micro:bit there is a strange set of golden lines (it's not gold, don't start to rip it appart and try selling it!). Those are conductive connectors that will allow you to connect more sensors and actuators to the board. They are what we call inputs and outputs or GPIO (general purpose input/ouputs) which are standards in the world of microcontrollers. Each little golden line is called a pin, and can be used as input or output. The micro:bit has 19 of them in total (more information here ). Adding a simple sensor In the material you received, you should have one blue knob per micro:bit. This knob is called a potentiometer. To start simple, we'll see how to capture the position of this potentiometer in out program. Later we'll see how to activate a motor depending on this measure we receive from the potentiometer. First, you need to connect physically the potentiometer to the micro:bit. For this I invite you to take the bit:buggy mainboard and attach the micro:bit onto it using 5 screws (see figures below). Then connect the potentiometer using the black/red/yellow dupont wire to the buggy board where it is written 0VG. Align the black wire to the letter G on the potentiometer and on the buggy board. Screwing onto the buggy mainboard Connecting the potentiometer DO NOT PUT THE BATTERIES IN YET !! You might destroy the micro:bit if you do so... That's it, we are ready to get some information from our new sensor in our program. Remember the 0VG mark ? It means that we connected the sensor to pin0. To access the information coming from a pin on the micro:bit, it is simple, we have two functions available: read_analog() or read_digital() . If we are interested in getting a binary information (0 or 1), we use read_digital() . That's what we'd use for a button (pressed or not). If we want more, as it is the case with our potentiometer, we have to use the function read_analog() . Exercice 1 1.1. Program micro:bit to display the value returned by pin0.read_analog() using the function display.show(). Turn the knob to find what is the range of values that pin0.read_analog() can return. 1.2. Use the function displayPositiveNumber(n) defined this morning to display the position of the knob. For the curious ones who wonder what the three wires are, here is a bit more information: basically a sensor will most of the time require a power source, that's what the red and black wires are here for (red = 3.3Volts, black = ground), and it will output a signal here using the yellow wire. Controlling a motor We've been talking about mobile robots since the beginning, but for now we have to admit it hasn't been very mobile... Let's work on that. It's now time to connect a motor to ouor board. For this get one of the motors uot of the bit:buggy kit, and plug it as shown in the image below (connection on pin1, taking care of putting the black wire facing the letter G). There are many kinds of motor. We will come back on this later. The one you'll use now is called a continuous servo motor. While the way it works will lickely seem a bit obscure, it is a great choice to start with as it is very easy to control. Servo motors are controlled using pulse width modulation (PWM). The speed of the one we have here is controlled with a squared signal with a period of 10 milliseconds and a duty cycle going from 5% to 25%. Is that gibberish ? It might well be, but no worries, all you need to know is that to output a squared signal with a 10 ms period on pin1 you need to use the instruction pin1.set_analog_period(10) and to change the duty cycle from 5 to 25% we cann use the instruction pin1.write_analog(d) with d in [50-250]. If you want to know more about PWMs you can read this page and to know more about continuous servo motors this page . Exercice 2 2.1. Program the micro:bit to make the robot turn. Try different values for d to make it turn at different speeds. What argument do you need to give to the write_analog() function to make the motor stop ? 2.2. Program the micro:bit so that you can control the speed of the motor by turning the potentiometer. Measuring a distance Now that we are confortable with a simple sensor and actuator, it's time to complexify things a bit and use the HC-SR04. This sensor is a distance sennsor. One thing I like about itis that it makes a great link between physics and computer science. Here is how it works: it sends an ultrasound signal and it measures how long it takes to receive an echo, like bats do. Thanks to the time between the emission and the reception and a bit of physics ( distance = time * velocity ) you can estimate the distance of obstacles facing the sensor. Now for the electronics, that's where things get a bit tricky: the sensor need to be powered (2 cables) and it needs 2 pins connected to the controller, one output of the controller to say when it wants to send a signal, one input of the controller to be informed about the echo. As we'll see, in terms of programming, it is quite simple, however there is a big problem to solve before programming... When we were using the red and black cable from the buggy mainboard (without the batterie!) to powered the potentiometer and motor, it was working because both can run with 3.3 Volts which is the voltage of the micro:bit. Here is the problem: HC-SR04 does not work with 3.3 V. It needs 5 Volts. This gives a two-sided problem: The micro:bit can not power up the HC-SR04; The HC-SR04, if it is powered correctly, will output a 5V signal as its echo, while if we give 5V to a micro:bit input it is likely to burn it... But don't worry, we've got everything planned: To power get 5V it is easy, we simply have to put the batteries in the buggy mainboard annd turn on the switch. The power of the board will go from 3.3 to 5V. Then, do you remember the potentiometer ? We can use it as a sensor, as we did, but actually we can also use it as a voltage divider to lower the voltage of the echo signal down. The way we used it as a sensor was to connect it with 3.3V and the ground, and it outputed a portion of 3.3V depending on the position of the knob, which is what we measured with the micro:bit. Instead, we can now feed it with the 0 to 5V echo signal coming from the HC-SR04, and make it output a portion of that, making sure it does not goes over 3.3V. Also we need to not take a too small portion of the signal, for instance imagine we outputed 0% of the signal with the potentiometer, then we would not be able to understand when the echo is received on the micro:bit. To get it to work we need the high value of the signal to be 2.3 Volt minimum (2.3 = 0.7 * 3.3... see here for more information). Therefore if we put the knob at its mid position, it should output a signal oscillating in between 0 and 2.5V and it should work. So practically, here is what to do: as shown in the pictures below, power the HC-SR04 (red wire goes from VCC to V and black from ground to G); connect pin0 to Trig for micro:bt to send the trigger; put the knob oof the potentiometer at its mid position and connect it to echo and the micro:bit to generate a safe echo for micro:bit (orange from echo to V, black from G to G, white from S to 1). Montage Circuit diagram Congratulation ! Our circuit is ready and its time to come back closer to our confort zone. Here is the function that we will use to measure the distance of an obstacle using our montage in centimeters. from microbit import * import machine import utime pinTrig = pin0 pinEcho = pin1 def get_dist_in_cm(): # send a pulse pinTrig.write_digital(0) utime.sleep_us(2) pinTrig.write_digital(1) utime.sleep_us(10) pinTrig.write_digital(0) # measure the time it takes for the echo to come back in microseconds # timeout in 10000 us = 0.01 s d = machine.time_pulse_us(pinEcho,1,10000) if d>0: # echo received return d/Constant else: #timeout return d Exercice 3 3.1. Read the code to verify if it matches the sensor specifications that we defined previously. Will this work if I call the function get_dist() ? 3.2. It won't work ! There is something missing: Constant is not defined and that because I want you to find it using the laws of physics. 3.3. Once you found the value of Constant , write a program to display the distance using the function displayPositiveNumber(n) . Solution exercice 3 In the environment we work in, the sounds travel at about 343 meters per seconds. That corresponds to 0.0343 centimeters per microseconds. While distance = time x velocity , in our case the distance is travelled back and forth, therefore we have 2 x distance = time x velocity . Which leads to d = t x v / 2 = t x 0.01715 = t / 58.3 . Conclusion That's it for today. It's time to unplug everything and turn the buggy mainboard off using it's switch, to save the batteries for the coming days. Thanks to what you've been learning today, you've got all the tools in your hands to already make an autonomous robot. While this morning you learned to interact with the controller of a robot, now you know how to give it eyes and muscles. Moreover while your familiarity with the use of functions is growing, reusing the work we did today will be a piece of cake. Just see how the function displayPositiveNumber(n) made our lives easier this afternoon to get a quick feedback from our sensors. Well all the work we did with the motor and the distance sensor this afternoon will be easily reusable too in the coming days. Talking about ease... This afternoon we dabbled in the world of electronics, and I know this can be intimidating at first. But like most other domains, by repetitive explorations out of your confort zone, you make your confort zone wider and soon this field can be yours to play with. But now time to rest and see you tomorrow for some more challenges !","title":"2 - Inputs and outputs"},{"location":"gpio/#input-and-outputs","text":"This morning we saw how the micro:bit comes equipped with integrated sensors and actuators, but we can all agree that for mobile robotics it might be a bit short of muscles. This afternoon you'll see how it is possible to add sensors and actuators to the micro:bit to go toward our goal of building an autonomous mobile robot.","title":"Input and outputs"},{"location":"gpio/#gpio","text":"As you might have already noticed, on the bottom of the micro:bit there is a strange set of golden lines (it's not gold, don't start to rip it appart and try selling it!). Those are conductive connectors that will allow you to connect more sensors and actuators to the board. They are what we call inputs and outputs or GPIO (general purpose input/ouputs) which are standards in the world of microcontrollers. Each little golden line is called a pin, and can be used as input or output. The micro:bit has 19 of them in total (more information here ).","title":"GPIO"},{"location":"gpio/#adding-a-simple-sensor","text":"In the material you received, you should have one blue knob per micro:bit. This knob is called a potentiometer. To start simple, we'll see how to capture the position of this potentiometer in out program. Later we'll see how to activate a motor depending on this measure we receive from the potentiometer. First, you need to connect physically the potentiometer to the micro:bit. For this I invite you to take the bit:buggy mainboard and attach the micro:bit onto it using 5 screws (see figures below). Then connect the potentiometer using the black/red/yellow dupont wire to the buggy board where it is written 0VG. Align the black wire to the letter G on the potentiometer and on the buggy board. Screwing onto the buggy mainboard Connecting the potentiometer DO NOT PUT THE BATTERIES IN YET !! You might destroy the micro:bit if you do so... That's it, we are ready to get some information from our new sensor in our program. Remember the 0VG mark ? It means that we connected the sensor to pin0. To access the information coming from a pin on the micro:bit, it is simple, we have two functions available: read_analog() or read_digital() . If we are interested in getting a binary information (0 or 1), we use read_digital() . That's what we'd use for a button (pressed or not). If we want more, as it is the case with our potentiometer, we have to use the function read_analog() . Exercice 1 1.1. Program micro:bit to display the value returned by pin0.read_analog() using the function display.show(). Turn the knob to find what is the range of values that pin0.read_analog() can return. 1.2. Use the function displayPositiveNumber(n) defined this morning to display the position of the knob. For the curious ones who wonder what the three wires are, here is a bit more information: basically a sensor will most of the time require a power source, that's what the red and black wires are here for (red = 3.3Volts, black = ground), and it will output a signal here using the yellow wire.","title":"Adding a simple sensor"},{"location":"gpio/#controlling-a-motor","text":"We've been talking about mobile robots since the beginning, but for now we have to admit it hasn't been very mobile... Let's work on that. It's now time to connect a motor to ouor board. For this get one of the motors uot of the bit:buggy kit, and plug it as shown in the image below (connection on pin1, taking care of putting the black wire facing the letter G). There are many kinds of motor. We will come back on this later. The one you'll use now is called a continuous servo motor. While the way it works will lickely seem a bit obscure, it is a great choice to start with as it is very easy to control. Servo motors are controlled using pulse width modulation (PWM). The speed of the one we have here is controlled with a squared signal with a period of 10 milliseconds and a duty cycle going from 5% to 25%. Is that gibberish ? It might well be, but no worries, all you need to know is that to output a squared signal with a 10 ms period on pin1 you need to use the instruction pin1.set_analog_period(10) and to change the duty cycle from 5 to 25% we cann use the instruction pin1.write_analog(d) with d in [50-250]. If you want to know more about PWMs you can read this page and to know more about continuous servo motors this page . Exercice 2 2.1. Program the micro:bit to make the robot turn. Try different values for d to make it turn at different speeds. What argument do you need to give to the write_analog() function to make the motor stop ? 2.2. Program the micro:bit so that you can control the speed of the motor by turning the potentiometer.","title":"Controlling a motor"},{"location":"gpio/#measuring-a-distance","text":"Now that we are confortable with a simple sensor and actuator, it's time to complexify things a bit and use the HC-SR04. This sensor is a distance sennsor. One thing I like about itis that it makes a great link between physics and computer science. Here is how it works: it sends an ultrasound signal and it measures how long it takes to receive an echo, like bats do. Thanks to the time between the emission and the reception and a bit of physics ( distance = time * velocity ) you can estimate the distance of obstacles facing the sensor. Now for the electronics, that's where things get a bit tricky: the sensor need to be powered (2 cables) and it needs 2 pins connected to the controller, one output of the controller to say when it wants to send a signal, one input of the controller to be informed about the echo. As we'll see, in terms of programming, it is quite simple, however there is a big problem to solve before programming... When we were using the red and black cable from the buggy mainboard (without the batterie!) to powered the potentiometer and motor, it was working because both can run with 3.3 Volts which is the voltage of the micro:bit. Here is the problem: HC-SR04 does not work with 3.3 V. It needs 5 Volts. This gives a two-sided problem: The micro:bit can not power up the HC-SR04; The HC-SR04, if it is powered correctly, will output a 5V signal as its echo, while if we give 5V to a micro:bit input it is likely to burn it... But don't worry, we've got everything planned: To power get 5V it is easy, we simply have to put the batteries in the buggy mainboard annd turn on the switch. The power of the board will go from 3.3 to 5V. Then, do you remember the potentiometer ? We can use it as a sensor, as we did, but actually we can also use it as a voltage divider to lower the voltage of the echo signal down. The way we used it as a sensor was to connect it with 3.3V and the ground, and it outputed a portion of 3.3V depending on the position of the knob, which is what we measured with the micro:bit. Instead, we can now feed it with the 0 to 5V echo signal coming from the HC-SR04, and make it output a portion of that, making sure it does not goes over 3.3V. Also we need to not take a too small portion of the signal, for instance imagine we outputed 0% of the signal with the potentiometer, then we would not be able to understand when the echo is received on the micro:bit. To get it to work we need the high value of the signal to be 2.3 Volt minimum (2.3 = 0.7 * 3.3... see here for more information). Therefore if we put the knob at its mid position, it should output a signal oscillating in between 0 and 2.5V and it should work. So practically, here is what to do: as shown in the pictures below, power the HC-SR04 (red wire goes from VCC to V and black from ground to G); connect pin0 to Trig for micro:bt to send the trigger; put the knob oof the potentiometer at its mid position and connect it to echo and the micro:bit to generate a safe echo for micro:bit (orange from echo to V, black from G to G, white from S to 1). Montage Circuit diagram Congratulation ! Our circuit is ready and its time to come back closer to our confort zone. Here is the function that we will use to measure the distance of an obstacle using our montage in centimeters. from microbit import * import machine import utime pinTrig = pin0 pinEcho = pin1 def get_dist_in_cm(): # send a pulse pinTrig.write_digital(0) utime.sleep_us(2) pinTrig.write_digital(1) utime.sleep_us(10) pinTrig.write_digital(0) # measure the time it takes for the echo to come back in microseconds # timeout in 10000 us = 0.01 s d = machine.time_pulse_us(pinEcho,1,10000) if d>0: # echo received return d/Constant else: #timeout return d Exercice 3 3.1. Read the code to verify if it matches the sensor specifications that we defined previously. Will this work if I call the function get_dist() ? 3.2. It won't work ! There is something missing: Constant is not defined and that because I want you to find it using the laws of physics. 3.3. Once you found the value of Constant , write a program to display the distance using the function displayPositiveNumber(n) . Solution exercice 3 In the environment we work in, the sounds travel at about 343 meters per seconds. That corresponds to 0.0343 centimeters per microseconds. While distance = time x velocity , in our case the distance is travelled back and forth, therefore we have 2 x distance = time x velocity . Which leads to d = t x v / 2 = t x 0.01715 = t / 58.3 .","title":"Measuring a distance"},{"location":"gpio/#conclusion","text":"That's it for today. It's time to unplug everything and turn the buggy mainboard off using it's switch, to save the batteries for the coming days. Thanks to what you've been learning today, you've got all the tools in your hands to already make an autonomous robot. While this morning you learned to interact with the controller of a robot, now you know how to give it eyes and muscles. Moreover while your familiarity with the use of functions is growing, reusing the work we did today will be a piece of cake. Just see how the function displayPositiveNumber(n) made our lives easier this afternoon to get a quick feedback from our sensors. Well all the work we did with the motor and the distance sensor this afternoon will be easily reusable too in the coming days. Talking about ease... This afternoon we dabbled in the world of electronics, and I know this can be intimidating at first. But like most other domains, by repetitive explorations out of your confort zone, you make your confort zone wider and soon this field can be yours to play with. But now time to rest and see you tomorrow for some more challenges !","title":"Conclusion"},{"location":"mecanics/","text":"Designing a robot Question With everything you learned so far and the material at hand, do you think that you could put together an autonomous mobile robot that will explore it's surounding while avoiding obstacles ? Introduction to making Build the cardboard buggy by following the instructions below: (Todo) Obstacle avoiding robot design Exercise 1 1.1 Design (without building) a new frame for your robot to be able to explore its environment and detect obstacles. 1.2 Choose among your design and the one proposed design which of the two you prefer annd build it. 1.3 Program your mobil robot to explore the space and avoid obstacles. CAD Now that you are more familiar to the parts and some mechanical constraints, you'll get further in the design process. Imagine you don't have only cardboard to build from, but you are planning to get access to a fablab where you'll have the possibility to use acrylic sheets and a laser cuter. Exercise 2 2.1 By following the instruction video here (todo), learn the fundamental about computer aided design. 2.2 Invent your own obstacle avoiding robot design. Conclusion","title":"3 - Designing and building"},{"location":"mecanics/#designing-a-robot","text":"Question With everything you learned so far and the material at hand, do you think that you could put together an autonomous mobile robot that will explore it's surounding while avoiding obstacles ?","title":"Designing a robot"},{"location":"mecanics/#introduction-to-making","text":"Build the cardboard buggy by following the instructions below: (Todo)","title":"Introduction to making"},{"location":"mecanics/#obstacle-avoiding-robot-design","text":"Exercise 1 1.1 Design (without building) a new frame for your robot to be able to explore its environment and detect obstacles. 1.2 Choose among your design and the one proposed design which of the two you prefer annd build it. 1.3 Program your mobil robot to explore the space and avoid obstacles.","title":"Obstacle avoiding robot design"},{"location":"mecanics/#cad","text":"Now that you are more familiar to the parts and some mechanical constraints, you'll get further in the design process. Imagine you don't have only cardboard to build from, but you are planning to get access to a fablab where you'll have the possibility to use acrylic sheets and a laser cuter. Exercise 2 2.1 By following the instruction video here (todo), learn the fundamental about computer aided design. 2.2 Invent your own obstacle avoiding robot design.","title":"CAD"},{"location":"mecanics/#conclusion","text":"","title":"Conclusion"},{"location":"microbit/","text":"Introduction to micro:bit This morning, you will discover what will be the brain of our mobile robots: the micro:bit. You'll see that this controllers comes already out of the box with sensors and actuators, which are the building blocks of a robot, and you'll learn how to interact with them. Why micro:bit Different options: raspberry:pi: small size computer, GPIO, great for mobile robotics, can plug a cameras and everything we can plug on a standard computer, but complex system, not ideal for beginning. adruino: great community, great capabilities, but does not come with integrated sensors and actuators, need electronics knowledge, soldering micro:bit: recent but growing community, comes with integrated sensors and actuators which allow for smooth learning curve, easy interface with extensions, python langage. Limited amount of memory but not a problem at the start. Programming Micro:bit Example program Let's get started. For now, we'll only need the micro:bit board, a computer with a web browser (Chrome preferably), and a cable to connect the computer and the micro:bit. So take this with you and connect everything together. You should see an external drive appear on your computer called MICROBIT . Now you'll use the web browser to access a Python online editor for micro:bit . It you go on this page you'll be facing with a big black area with some python code. This area is the editor where you'll type your programs. On top of that you should see different buttons/icons that will allow you to interact with your computer, and the micro:bit directly if you are using Chrome. For now, before doing any programming, let's see how you can put the example \"Hello, World!\" program onto the micro:bit. First option: you click the Download button. This will download the program as an .hex file named microbit_program.hex . To put it in the micro:bit, simply drag and drop the .hex to the MICROBIT external drive. - Second option if you have chrome: click Connect , select the micro:bit in the menu and click again on connect, and now the Download button should have transformed into a Flash button. This button allows you to directly put (flash) the program from the web-browser to the micro:bit. At the end of both options, an orange LED should blink on the micro:bit, informing you about the transmission. When the transfer is over the program should start automatically and you should see the execution of the program on the red LEDs of the micro:bit. Congratulation, you gave your first program to the micro:bit ! Your first program Using the example program from above, you'll now learn the standard structure of the programs in micro-controllers. This structure is and always will almost always be as follow: first, an initialisation, then a loop. Take the time to identify those two parts in the previous program. Following the same structure, here is a program to show you some functions that are available to use its buttons and LED matrix in python: # Initialisation # Get standard librairies from microbit import * # Loop while True: if button_a.was_pressed(): display.set_pixel(0,2,9) sleep(1000) display.clear() if button_b.was_pressed(): display.set_pixel(4,2,9) sleep(1000) display.clear() sleep(100) Exercice 1 1.1 Work out how the functions set_pixel() and sleep() work by either by reading the doc ( sleep doc , display doc ) or by tinkering with the code... or both ! 1.2 If you tinkered with the code, you might have made mistakes. If you did not, try it out and for instance try to execute the instruction display.set_pixel(-1,2,9) and see what happens. Normally you should see the error \"Line ... valueError index out of bounds\". That's basically what will happen if you ask the micro:bit to do something it cannot do. It will tell you what's his problem (the line), and why (in this case the first argument of set_pixel can only accept values from 0 to 4). Variable control and display Now that you know how to interact with micro:bit, it's time for you to bring your knowledge of python into play. The goal will be to define a function that will help us work with micro:bit all through the week. Indeed, the function display.show() is powerful and can show many types of variables (integers, floats, strings) and useful to debug and show us some valuable information. However, as we saw with our \"Hello, World!\" example, this function is also not very reactive, while we need to be reactive not to have to wait 2 seconds for each piece of information ! Exercice 2 2.1. Define an integer variable x , initialise it to 0 and display its value using display.show() . 2.2. Program the micro:bit so that you can use the buttons A and B to increase and decrease the value of x 2.3. Instead of using display.show() , use a loop and the function display.set_pixel() to display the value of x for x in [0-5] on the first line of LED: if x==1, 1 LED is on, if x == 2, 2 LEDs are on... 2.4. Define a function displayPositiveNumber(n) , that shows the value of an integer n (n in [0-25]) on the LED matrix We are going somewhere interesting with this function. If we plug some sensors to the micro:bit and we want to display some quantitative information coming from them, that's exactly the sort of function we need. However, for now, our resolution is very little (only 6 possible values can be displayed). To get a richer information, let's use the whole LED matrix. For this we'll define the following function: def displayPositiveNumber(d): display.clear() for i in range(25): if d>i: display.set_pixel(i%5,int(i/5),9) Exercice 3 3.1. On a piece of paper, represent a 5x5 grid and set a number for each row and column, starting on the top left. For i = {4,5,6,24} compute i%5 (meaning i mod 5 ... meaning the rest of the integer division of i by 5) and int(i/5) (meaning the integer part of i/5). Write down the value of i in the grid at the position (i%5,int(i/5)). 3.2. Integrate this function into the previous exercise to set the value of x using the buttons and display its value for x in [0-25]. 3.3. (Optional) Rewrite the displayPositiveNumber(d) function using nested loops (a loop in a loop). We are now equipped with a function which is going to be very useful this afternoon and in the coming days and which hopefully you understand well. Save it using the \"Load/Save\" button, followed by clicking the \"Downnload Python Script\" button. comment : <> ( Integrated sensors and actuators: When we build a robot, the main purpose is not data processing, it is to interact with the environment. For this a robot needs to perceive the environment and act upon it, and to do so it needs sensors and actuators. During the week, you'll see different types of sensors and actuators, but for now let's already see what comes integrated with the micro:bit. Sensors: buttons, accelerometer, compas, radio receiver; Actuators: led matrix, radio transmitter) Conclusion This morning you saw one key component of what makes a robot: its controller. The controller is the brain of the robot which does the interface between its sensors and its actuators. But you saw more than that. Indeed by programming the micro:bit you already had a quick go at doing the interface between some integrated sensors (buttons) and actuators (LED matrix) of the board. While this sensors/controller/actuators design is the standard design for mobile robots, it also applies to many other fields. Look around you and you'll see this arrangement is standard in technology as well as in life. Smartphones comes with sensors: a camera, touch(screen), microphones, radio receptor, accelerometer, compas; and with actuators: a screen, speakers and radio emettor. Humans comes with sensors too, although they are harder to isolate than on machine, but making it simple we could say that most of them come equipped with eyes, ears, nose, skin, tongue and proprioceptors (too often forgotten). We also saw that for the controller to make the link between the sensors and the actuators, you need to give it a program. While you used the micro:bit this morning, what you learn applies to most other controllers: a programming language is most of the time composed of standard building blocks such as instructions, variables, conditions, loops and functions the structure of the program of a robot comes almost always with an initialisation and a loop (and sometimes with interrupts but I invite you to discover this when you are already familiar with the basics).","title":"1 - Micro:bit board"},{"location":"microbit/#introduction-to-microbit","text":"This morning, you will discover what will be the brain of our mobile robots: the micro:bit. You'll see that this controllers comes already out of the box with sensors and actuators, which are the building blocks of a robot, and you'll learn how to interact with them.","title":"Introduction to micro:bit"},{"location":"microbit/#why-microbit","text":"Different options: raspberry:pi: small size computer, GPIO, great for mobile robotics, can plug a cameras and everything we can plug on a standard computer, but complex system, not ideal for beginning. adruino: great community, great capabilities, but does not come with integrated sensors and actuators, need electronics knowledge, soldering micro:bit: recent but growing community, comes with integrated sensors and actuators which allow for smooth learning curve, easy interface with extensions, python langage. Limited amount of memory but not a problem at the start.","title":"Why micro:bit"},{"location":"microbit/#programming-microbit","text":"","title":"Programming Micro:bit"},{"location":"microbit/#example-program","text":"Let's get started. For now, we'll only need the micro:bit board, a computer with a web browser (Chrome preferably), and a cable to connect the computer and the micro:bit. So take this with you and connect everything together. You should see an external drive appear on your computer called MICROBIT . Now you'll use the web browser to access a Python online editor for micro:bit . It you go on this page you'll be facing with a big black area with some python code. This area is the editor where you'll type your programs. On top of that you should see different buttons/icons that will allow you to interact with your computer, and the micro:bit directly if you are using Chrome. For now, before doing any programming, let's see how you can put the example \"Hello, World!\" program onto the micro:bit. First option: you click the Download button. This will download the program as an .hex file named microbit_program.hex . To put it in the micro:bit, simply drag and drop the .hex to the MICROBIT external drive. - Second option if you have chrome: click Connect , select the micro:bit in the menu and click again on connect, and now the Download button should have transformed into a Flash button. This button allows you to directly put (flash) the program from the web-browser to the micro:bit. At the end of both options, an orange LED should blink on the micro:bit, informing you about the transmission. When the transfer is over the program should start automatically and you should see the execution of the program on the red LEDs of the micro:bit. Congratulation, you gave your first program to the micro:bit !","title":"Example program"},{"location":"microbit/#your-first-program","text":"Using the example program from above, you'll now learn the standard structure of the programs in micro-controllers. This structure is and always will almost always be as follow: first, an initialisation, then a loop. Take the time to identify those two parts in the previous program. Following the same structure, here is a program to show you some functions that are available to use its buttons and LED matrix in python: # Initialisation # Get standard librairies from microbit import * # Loop while True: if button_a.was_pressed(): display.set_pixel(0,2,9) sleep(1000) display.clear() if button_b.was_pressed(): display.set_pixel(4,2,9) sleep(1000) display.clear() sleep(100) Exercice 1 1.1 Work out how the functions set_pixel() and sleep() work by either by reading the doc ( sleep doc , display doc ) or by tinkering with the code... or both ! 1.2 If you tinkered with the code, you might have made mistakes. If you did not, try it out and for instance try to execute the instruction display.set_pixel(-1,2,9) and see what happens. Normally you should see the error \"Line ... valueError index out of bounds\". That's basically what will happen if you ask the micro:bit to do something it cannot do. It will tell you what's his problem (the line), and why (in this case the first argument of set_pixel can only accept values from 0 to 4).","title":"Your first program"},{"location":"microbit/#variable-control-and-display","text":"Now that you know how to interact with micro:bit, it's time for you to bring your knowledge of python into play. The goal will be to define a function that will help us work with micro:bit all through the week. Indeed, the function display.show() is powerful and can show many types of variables (integers, floats, strings) and useful to debug and show us some valuable information. However, as we saw with our \"Hello, World!\" example, this function is also not very reactive, while we need to be reactive not to have to wait 2 seconds for each piece of information ! Exercice 2 2.1. Define an integer variable x , initialise it to 0 and display its value using display.show() . 2.2. Program the micro:bit so that you can use the buttons A and B to increase and decrease the value of x 2.3. Instead of using display.show() , use a loop and the function display.set_pixel() to display the value of x for x in [0-5] on the first line of LED: if x==1, 1 LED is on, if x == 2, 2 LEDs are on... 2.4. Define a function displayPositiveNumber(n) , that shows the value of an integer n (n in [0-25]) on the LED matrix We are going somewhere interesting with this function. If we plug some sensors to the micro:bit and we want to display some quantitative information coming from them, that's exactly the sort of function we need. However, for now, our resolution is very little (only 6 possible values can be displayed). To get a richer information, let's use the whole LED matrix. For this we'll define the following function: def displayPositiveNumber(d): display.clear() for i in range(25): if d>i: display.set_pixel(i%5,int(i/5),9) Exercice 3 3.1. On a piece of paper, represent a 5x5 grid and set a number for each row and column, starting on the top left. For i = {4,5,6,24} compute i%5 (meaning i mod 5 ... meaning the rest of the integer division of i by 5) and int(i/5) (meaning the integer part of i/5). Write down the value of i in the grid at the position (i%5,int(i/5)). 3.2. Integrate this function into the previous exercise to set the value of x using the buttons and display its value for x in [0-25]. 3.3. (Optional) Rewrite the displayPositiveNumber(d) function using nested loops (a loop in a loop). We are now equipped with a function which is going to be very useful this afternoon and in the coming days and which hopefully you understand well. Save it using the \"Load/Save\" button, followed by clicking the \"Downnload Python Script\" button. comment : <> ( Integrated sensors and actuators: When we build a robot, the main purpose is not data processing, it is to interact with the environment. For this a robot needs to perceive the environment and act upon it, and to do so it needs sensors and actuators. During the week, you'll see different types of sensors and actuators, but for now let's already see what comes integrated with the micro:bit. Sensors: buttons, accelerometer, compas, radio receiver; Actuators: led matrix, radio transmitter)","title":"Variable control and display"},{"location":"microbit/#conclusion","text":"This morning you saw one key component of what makes a robot: its controller. The controller is the brain of the robot which does the interface between its sensors and its actuators. But you saw more than that. Indeed by programming the micro:bit you already had a quick go at doing the interface between some integrated sensors (buttons) and actuators (LED matrix) of the board. While this sensors/controller/actuators design is the standard design for mobile robots, it also applies to many other fields. Look around you and you'll see this arrangement is standard in technology as well as in life. Smartphones comes with sensors: a camera, touch(screen), microphones, radio receptor, accelerometer, compas; and with actuators: a screen, speakers and radio emettor. Humans comes with sensors too, although they are harder to isolate than on machine, but making it simple we could say that most of them come equipped with eyes, ears, nose, skin, tongue and proprioceptors (too often forgotten). We also saw that for the controller to make the link between the sensors and the actuators, you need to give it a program. While you used the micro:bit this morning, what you learn applies to most other controllers: a programming language is most of the time composed of standard building blocks such as instructions, variables, conditions, loops and functions the structure of the program of a robot comes almost always with an initialisation and a loop (and sometimes with interrupts but I invite you to discover this when you are already familiar with the basics).","title":"Conclusion"},{"location":"python/","text":"Introduction to Python During the upcoming robotics summerschool, I'll need you to be confortable with the basics of python programming. I wrote this page using embedded codes to have everyone starting with the bare minimum going from a simple \"Hello world\" script to using variables, loops, conditions and functions. As the program of the summerschool will be intense, I'll need most of you to be confortable with those. Comments and simple instructions For each section of this page I'll use embedded code that allow you to run python scripts without leaving this page, and interact with the code as you wish. So let's go: read the code, try to predict what's going to happen in the terminal (in black), and press the pay button. Again, don't hesitate to change the code and press play again to try things out, anything ! For that you can also directly type instructions in the terminal (the black window). Variables and standard operations Computers are so useful to us because they don't always to the same things over and over. It's the same with mobile robots, they can adapt to their environment. This would be impossible to do without taking into account some variations in our programs. To deal with those variations, we use what we call variables. A variable is like a box where we put some information that can vary during the execution of a program. Same here, change the code, make it crash ! (Even more than it already does !) Loops Another way computers and robots change our lives is in their ability to cope with repetitive task without being bored. But the programmer who programmed them gets easily bored, so he needs to have a tool to take care of repetitions in is code. That's what loops are for. Exercice 1 Add some lines in the script above to display the 20 first numbers of the Fibonacci sequence. Solution exercice 1 Functions Do you know what assembly language is ? Take a few seconds to have a look at it on wikipedia and try to decipher what the program in the top right image does... That's not the language you want to program in every day ! Take some time to contemplate the chance you have to not go through that and instead use python. Well, you have this chance partly thanks to functions. As in mathematics, functions can take arguments and return a value. You should have all by now used the cosine function. Cosine takes onoe parameter, an angle, and returns a value in between -1 and 1. In computer science, functions come in many forms. They can take argumet(s) or not. They can return values but they don't have to (in this case we could call it a procedure). Such a tool allow to make our code readable, less repetitive, and combine and build functions with and on one another. That's how, thanks to programmers, your computer can understand some high level langage like python, while at its core it can only understand assembly. Let's see how to use this incredible tool on python. Exercice 2 Define a function with one parameter n that compute and return the golden ratio using the fibonacci n th and n+1 th numbers. Solution exercice 2 See how simple the exercise is if we use the predefined fibonacci function. The exercise would have been much harder if we had to start from scratch. Conditions In our programs, depending on some variables, sometimes we want to do things, sometimes we don't. To perform such a feat the last ingredient we are missing in our arsenal of tools are conditions. Conditions are quite simple and we use them everyday: Does it rain ? Yes/No => Take an umbrella/Don't. Note that in computer science, conditions are made of: a test resulting in a boolean (True or False), what to do if the test is True, and sometimes what to do if it is not. Exercice 3 Modify the code following the instructions inside it. Solution exercice 3 Conclusion That's all for now. Thanks for going through this introduction and I see you soon to use those new skills of yours to discover the world of mobile robotics.","title":"0 - Introduction to Python"},{"location":"python/#introduction-to-python","text":"During the upcoming robotics summerschool, I'll need you to be confortable with the basics of python programming. I wrote this page using embedded codes to have everyone starting with the bare minimum going from a simple \"Hello world\" script to using variables, loops, conditions and functions. As the program of the summerschool will be intense, I'll need most of you to be confortable with those.","title":"Introduction to Python"},{"location":"python/#comments-and-simple-instructions","text":"For each section of this page I'll use embedded code that allow you to run python scripts without leaving this page, and interact with the code as you wish. So let's go: read the code, try to predict what's going to happen in the terminal (in black), and press the pay button. Again, don't hesitate to change the code and press play again to try things out, anything ! For that you can also directly type instructions in the terminal (the black window).","title":"Comments and simple instructions"},{"location":"python/#variables-and-standard-operations","text":"Computers are so useful to us because they don't always to the same things over and over. It's the same with mobile robots, they can adapt to their environment. This would be impossible to do without taking into account some variations in our programs. To deal with those variations, we use what we call variables. A variable is like a box where we put some information that can vary during the execution of a program. Same here, change the code, make it crash ! (Even more than it already does !)","title":"Variables and standard operations"},{"location":"python/#loops","text":"Another way computers and robots change our lives is in their ability to cope with repetitive task without being bored. But the programmer who programmed them gets easily bored, so he needs to have a tool to take care of repetitions in is code. That's what loops are for. Exercice 1 Add some lines in the script above to display the 20 first numbers of the Fibonacci sequence. Solution exercice 1","title":"Loops"},{"location":"python/#functions","text":"Do you know what assembly language is ? Take a few seconds to have a look at it on wikipedia and try to decipher what the program in the top right image does... That's not the language you want to program in every day ! Take some time to contemplate the chance you have to not go through that and instead use python. Well, you have this chance partly thanks to functions. As in mathematics, functions can take arguments and return a value. You should have all by now used the cosine function. Cosine takes onoe parameter, an angle, and returns a value in between -1 and 1. In computer science, functions come in many forms. They can take argumet(s) or not. They can return values but they don't have to (in this case we could call it a procedure). Such a tool allow to make our code readable, less repetitive, and combine and build functions with and on one another. That's how, thanks to programmers, your computer can understand some high level langage like python, while at its core it can only understand assembly. Let's see how to use this incredible tool on python. Exercice 2 Define a function with one parameter n that compute and return the golden ratio using the fibonacci n th and n+1 th numbers. Solution exercice 2 See how simple the exercise is if we use the predefined fibonacci function. The exercise would have been much harder if we had to start from scratch.","title":"Functions"},{"location":"python/#conditions","text":"In our programs, depending on some variables, sometimes we want to do things, sometimes we don't. To perform such a feat the last ingredient we are missing in our arsenal of tools are conditions. Conditions are quite simple and we use them everyday: Does it rain ? Yes/No => Take an umbrella/Don't. Note that in computer science, conditions are made of: a test resulting in a boolean (True or False), what to do if the test is True, and sometimes what to do if it is not. Exercice 3 Modify the code following the instructions inside it. Solution exercice 3","title":"Conditions"},{"location":"python/#conclusion","text":"That's all for now. Thanks for going through this introduction and I see you soon to use those new skills of yours to discover the world of mobile robotics.","title":"Conclusion"},{"location":"robot/","text":"Mobile robotics - Control Yesterday, you learned how to make a robot sense and how to make it act on its environment. But there was a big things missing to make the robot really move: a frame, a structure to hold all the parts together, we could say the bones of our mobile robot. Today we'll solve this problem: you'll build a frame, and following you will discover some standard mobile robotics problems and learn how to solve them. Building the big:buggy To build the robot, I invite you to follow the instructions provided in the Bit:Buggy isntruction manual. However this manual is missing some valuable information: Before starting identify the two bags that come along with the servo motors (in them there should screws and several servo horns, that is white plastic pieces to put on the servos). Those pieces won't be of any use and are not listed in the component list of the bit:buggy car, so put them aside. In step 1. pay attention to the wheels: their two sides are differents, only one side can plug onto the motor end. Also, when screwing the wheel onto the motor, hold the wheel (if you don't you could make the motor turn using the screws and that might damage the motor). In step 3. make the cables of the motors stick upward. Moreover you have to push through to really get the plastic parts completely in one another. In step 4. be delicate with the screw. You should not have to force. If it's hard to screw it in, it's probably that the alignment is ot correct. If it is, unscrew first, correct the alignment and try screwing again. Before step 6 put the batteries in if it is not yet in, and turn off the board with the switch. After step 6, when you plug the cables, remember you learned today: the black cable plugs onto G ! The picture of the instructions might be a bit misleading. By the way the cables are long (not like the picture), simply tuck them inside the robot frame and you are ready to roll. Moving basics Now that we've got some bones to hold our muscles, eyes and brain, it's time for you to remember what you learned today to do a simple program to make the buggy move. Exercice 1 1.1 Program micro:bit to move forward when the robot move forward when the button A is pressed and stop when B is pressed. 1.2 Rewrite your program to make it clean and reusable: define the functions setLeftSpeed(v) and setRightSpeed(v) for v in [-100, 100] so that to go straight at full speed we just have to call setLeftSpeed(100) and setRightSpeed(100) . 1.3 Rewrite your program to make it even cleaner and reusable: define a function goStraight(v) that can be used to make the robot move forward (or stop) at the speed we want. Control laws Exercise: program the buggy to always follow the steepest ascent. ON/OFF control law. Proportional control law. Focus on problem decomposition: first one dimension, then second, then join them. Conclusion and afternoon program Remainder of lessons learned. Afternoon in autonomy (Anthony available for questions): First period: Everyone takes time to go through the previous exercises and identify if there has been anything left unclear. If there is discuss with the group to clarify the situation and do the corresponding exercise again if needed. Second period: Discovering the radio emettor and receptor. Final goal: control the buggy from another micro:bit by tilting it. Again focus on problem decomposition. Optional 1: Control the buggy using another micro:bit equipped with two potentiometers (remove the batteries if you do so to make sure you don't give 5V to micro:bit and burn it). One potentiometer for the forward/backward speed, the other for turning (like on many RC vehicles) Optional 2 (hard): Program the buggy to always come back to the orientation it started with. For this you'll need to use it's internal compas which is quite a special sensor.","title":"3 - Robotics and moving"},{"location":"robot/#mobile-robotics-control","text":"Yesterday, you learned how to make a robot sense and how to make it act on its environment. But there was a big things missing to make the robot really move: a frame, a structure to hold all the parts together, we could say the bones of our mobile robot. Today we'll solve this problem: you'll build a frame, and following you will discover some standard mobile robotics problems and learn how to solve them.","title":"Mobile robotics - Control"},{"location":"robot/#building-the-bigbuggy","text":"To build the robot, I invite you to follow the instructions provided in the Bit:Buggy isntruction manual. However this manual is missing some valuable information: Before starting identify the two bags that come along with the servo motors (in them there should screws and several servo horns, that is white plastic pieces to put on the servos). Those pieces won't be of any use and are not listed in the component list of the bit:buggy car, so put them aside. In step 1. pay attention to the wheels: their two sides are differents, only one side can plug onto the motor end. Also, when screwing the wheel onto the motor, hold the wheel (if you don't you could make the motor turn using the screws and that might damage the motor). In step 3. make the cables of the motors stick upward. Moreover you have to push through to really get the plastic parts completely in one another. In step 4. be delicate with the screw. You should not have to force. If it's hard to screw it in, it's probably that the alignment is ot correct. If it is, unscrew first, correct the alignment and try screwing again. Before step 6 put the batteries in if it is not yet in, and turn off the board with the switch. After step 6, when you plug the cables, remember you learned today: the black cable plugs onto G ! The picture of the instructions might be a bit misleading. By the way the cables are long (not like the picture), simply tuck them inside the robot frame and you are ready to roll.","title":"Building the big:buggy"},{"location":"robot/#moving-basics","text":"Now that we've got some bones to hold our muscles, eyes and brain, it's time for you to remember what you learned today to do a simple program to make the buggy move. Exercice 1 1.1 Program micro:bit to move forward when the robot move forward when the button A is pressed and stop when B is pressed. 1.2 Rewrite your program to make it clean and reusable: define the functions setLeftSpeed(v) and setRightSpeed(v) for v in [-100, 100] so that to go straight at full speed we just have to call setLeftSpeed(100) and setRightSpeed(100) . 1.3 Rewrite your program to make it even cleaner and reusable: define a function goStraight(v) that can be used to make the robot move forward (or stop) at the speed we want.","title":"Moving basics"},{"location":"robot/#control-laws","text":"Exercise: program the buggy to always follow the steepest ascent. ON/OFF control law. Proportional control law. Focus on problem decomposition: first one dimension, then second, then join them.","title":"Control laws"},{"location":"robot/#conclusion-and-afternoon-program","text":"Remainder of lessons learned. Afternoon in autonomy (Anthony available for questions): First period: Everyone takes time to go through the previous exercises and identify if there has been anything left unclear. If there is discuss with the group to clarify the situation and do the corresponding exercise again if needed. Second period: Discovering the radio emettor and receptor. Final goal: control the buggy from another micro:bit by tilting it. Again focus on problem decomposition. Optional 1: Control the buggy using another micro:bit equipped with two potentiometers (remove the batteries if you do so to make sure you don't give 5V to micro:bit and burn it). One potentiometer for the forward/backward speed, the other for turning (like on many RC vehicles) Optional 2 (hard): Program the buggy to always come back to the orientation it started with. For this you'll need to use it's internal compas which is quite a special sensor.","title":"Conclusion and afternoon program"}]}