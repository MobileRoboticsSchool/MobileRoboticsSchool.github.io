<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>Gpio - Mobile Robotics with micro:bit</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../css/theme.css" />
  <link rel="stylesheet" href="../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  <link href="../css/extra.css" rel="stylesheet" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "Gpio";
    var mkdocs_page_input_path = "gpio.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> Mobile Robotics with micro:bit</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="..">Welcome</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../python/">Introduction to Python</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../about/">Contacts</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">Mobile Robotics with micro:bit</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>Gpio</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="input-and-outputs">Input and outputs</h1>
<p>This morning we saw how the micro:bit comes equipped with integrated sensors and actuators. For mobile robotics, those are not enough, so this afternoon you'll see how it is possible to add sensors and actuators to the micro:bit to go towards our goal of building an autonomous mobile robot.</p>
<h2 id="what-you-will-need">What you will need</h2>
<table>
<thead>
<tr>
<th align="center">Buggy mainboard</th>
<th align="center">Potentiometer and wires</th>
<th align="center">Servo motor</th>
<th align="center">Ultrasound sensor</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><img alt="" src="Hardware/buggy_board.jpeg" /></td>
<td align="center"><img alt="" src="Hardware/potar_wires.jpeg" /></td>
<td align="center"><img alt="" src="Hardware/servo.jpeg" /></td>
<td align="center"><img alt="" src="Hardware/ultrasound.jpeg" /></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p><strong>Figure:</strong> Necessary equipment.</p>
</div>
<p>Every pair of learners will need:</p>
<ul>
<li>The equipment required in the previous session</li>
<li>One bit:buggy mainboard, 5 screws and a screwdriver (all in the bit:buggy box)</li>
<li>One potentiometer</li>
<li>6 Wires female-female </li>
<li>One servo motor (in the bit:buggy box)</li>
<li>One ultrasound sensor (the HC-SR04)</li>
<li>3 x AAA batteries</li>
</ul>
<h2 id="gpio">GPIO</h2>
<p>Look at the micro:bit. On its bottom there is a strange set of golden lines (it's not gold, don't start to rip it appart and try selling it!). Those are conductive connectors that will allow you to connect more sensors and actuators to it and interact with them. They are what we call inputs and outputs or GPIO (general purpose input/ouputs) which are standards in the world of microcontrollers. Each connector is called a <em>pin</em>, and most of them can be used as input or output. The micro:bit has about 20 of them in total (more information <a href="https://microbit-micropython.readthedocs.io/en/latest/pin.html">here</a>).</p>
<h2 id="adding-a-simple-sensor">Adding a simple sensor</h2>
<p>The first sensor you will add is called a potentiometer. For this you will use one pin as an input. You'll learn how to capture the position of the potentiometer in our program. </p>
<p>Before doing any programming, you will have to take care of the physical connection between the potentiometer and the micro:bit. <strong>Begin by disconnecting the micro:bit from the computer. Before doing any changes in the wiring of a controller, always power it off !</strong></p>
<p>Then, screw the micro:bit on the bit:buggy mainboard using 5 screws (see figures below). This will give you access to pin0, pin1, pin2, 3.3V and Ground through femelle pin headers on the back of the buggy board. In this activity, you will use the pins pin0 (0), 3.3V (V) and ground (G). Connect the wires as shown in the image below (the colors are not important although we usually try to put a black cable for ground and a red one for power sources).</p>
<table>
<thead>
<tr>
<th align="center">Screwing onto the buggy mainboard</th>
<th align="center">Connecting the potentiometer</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><img alt="" src="IMG_0139.jpg" style="height:350px;width:350px" /></td>
<td align="center"><img alt="" src="IMG_0142.png" style="height:350px;width:350px" /></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p><strong>Figure:</strong> Connecting the potentiometer to the micro:bit. <span style="color:red">DO NOT PUT THE BATTERIES IN YET !! You might destroy the micro:bit if you do so...</span></p>
</div>
<p>In this montage, the potentiometer will ouput through S (for signal) a portion of the input voltage (3.3V) depending on the position of the knob. </p>
<p>To access the information of the pins in python, the microbit library defines for us the objects <em>pin0</em>, <em>pin1</em>, etc... Those objects come with two useful functions: <em>read_analog()</em> or <em>read_digital()</em> (see <a href="https://microbit-micropython.readthedocs.io/en/latest/pin.html">doc here</a>). If we are interested in getting a binary information (is the voltage on the pin high or low?), we use <em>read_digital()</em>. That's what we'd use for a button (pressed or not). If we want more we have to use the function <em>read_analog()</em>. This is our case as we want to know the position of the knob, therefore, we want to know which portion of 3.3V is on pin0. </p>
<div class="admonition note">
<p class="admonition-title">exercise 1</p>
<ul>
<li>1.1. <em>pin0.read_analog()</em> returns an integer. Program micro:bit to display the value returned by this function using the function display.scroll() every 100 ms. Turn the knob to find what is the range of values that pin0.read_analog() can return. Can you display the value every 100 ms ?</li>
<li>1.2. Use the function <em>displayPositiveNumber(n)</em> defined this morning to display the position of the knob every 100 ms. Remember that this function works well only for arguments in [0-25], so you'll need to do some scaling in between.</li>
<li>1.3. (Optional) If you are not comfortable with linear mapping (rescaling in our case), you could later take the time to define a function to do that for you so that <em>map(n, n_min,n_max,res_min,res_max) = res_min + n.(res_max-res_min)/(n_max-n_min)</em>.</li>
</ul>
</div>
<details class="note"><summary>Solution exercise 1.1</summary><p>The value returned by <em>read_analog()</em> is not in any physical unit. It's just a number encoded in 10 bits, meaning that it's value can go theoretically from 0 to 1024. However, this corresponds to the measure of a voltage on pin0 that can go from 0 to 3.3V (and should never go above 3.3V !).</p>
</details>
<p>While there exist many kinds of sensors, many of them work in a similar fashion as the potentiometer. A sensor will often require a power source (3.3Volts and ground), and it will output a signal. </p>
<h2 id="controlling-a-motor">Controlling a motor</h2>
<p>Now that the micro:bit can sense, you will learn how to make it act on its environment with a motor. For this get one of the motors out of the bit:buggy kit. Notice that the motor comes with its cable. <strong>Power off the micro:bit by disconnecting it from the computer</strong>, then plug the motor as shown in the image below (connection on pin1, taking care of putting the brown/black wire facing the letter G). To make the rotation of the motor more noticeable, you can take one of the white plastic end that comes in the bag where you found the motor. This piece is called a servo horn and allow for easy mechanical constructions with the motor.</p>
<p><img alt="" src="IMG_0148.jpg" /></p>
<div class="admonition note">
<p><strong>Figure:</strong> Connecting the servo motor to the micro:bit. </p>
</div>
<p>There are many kinds of motor. We will come back to this later. The one you'll use now is called a continuous servo motor. While the way it works will likely seem a bit obscure, it is a great choice to start with as it is very easy to control as it requires no extra components.</p>
<p>If you are just interested in making the motor turn, skip this paragraph. For the others, here is a little theory: Servo motors are controlled using pulse width modulation (PWM). PWMs are signals made out of regular high voltage pulses with varying width. The motor will measure the width of the pulses and will turn depending on it. In our case, to control the servo motor, we need to send a high pulse every 10 milliseconds. The width of the pulse needs to be 5% to 25% the period of the pulse (0.5ms to 2.5ms long) to be taken into account by the motor. More about PWMs <a href="https://microbit-micropython.readthedocs.io/en/latest/pin.html">here</a> and more about continuous servo motors <a href="https://learn.adafruit.com/adafruit-motor-selection-guide/continuous-rotation-servos">here</a>.</p>
<p>Practically, to control the motor you will need to have pin1 output a high pulse with a 10 ms period. As the <a href="https://microbit-micropython.readthedocs.io/en/latest/pin.html">documentation</a> explains, to do so we can use the instruction <em>pin1.set_analog_period(10)</em>. To change its speed you will have to use the function <em>pin1.write_analog(d)</em> with <em>d</em> in [50-250]. </p>
<div class="admonition note">
<p class="admonition-title">exercise 2</p>
<ul>
<li>2.1. Program the micro:bit to make the motor turn. Try different values for <em>d</em> to make it turn at different speeds. What argument do you need to give to <em>the write_analog()</em> function to make the motor stop ? Does the function <em>pin1.set_analog_period(10)</em> need to be in the loop ?</li>
<li>2.2. Program the micro:bit so that you can control the speed of the motor by turning the potentiometer.</li>
<li>2.3. (Optional) Add a second motor and program the micro:bit so that you can set the speed of both motors independently using the buttons and potentiometer. Before programming, imagine how your idea would feel for the user to make it as user friendly as possible.</li>
</ul>
</div>
<p>Notice that the motor is quite similar to the potentiometer in terms of wiring: it needs a power supply (3.3V and ground) and a signal, except that this time the signal is going from the micro:bit to the motor. This applies to many actuators.</p>
<h2 id="measuring-a-distance">Measuring a distance</h2>
<p>The last component you will learn to interface today is the HC-SR04. The HC-SR04, while it is commonly called an "ultrasonic distance sensor" is both a sensor and an actuator. It sends an ultrasound signal when the controllers orders it to do so and it informs the controller when it receives an echo. Thanks to the time between emission and reception and a bit of physics (<em>distance = time * velocity</em>) we can estimate the distance of obstacles facing the sensor.</p>
<p>Do the montage shown in the pictures below. <strong>Add the batteries only once you double checked the montage</strong>. 
This montage is more complex than the previous ones and here is the reason why: </p>
<ul>
<li>The HC-SR04 needs about 5V of power and by adding the batteries the V pins of the buggy board go up from 3.3V to about 5V (more 3x1.5V in reality). </li>
<li>The HC-SR04 sends an echo of 5V which if plugged directly to micro:bit could burn it. The montage <strong>with the potentiometer set at its mid-position</strong> allows to solve this problem<sup id="fnref:1"><a class="footnote-ref" href="#fn:1">1</a></sup>.</li>
</ul>
<table>
<thead>
<tr>
<th align="center">Potentiometer at its mid-position</th>
<th align="center">Montage</th>
<th align="center">Circuit diagram</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><img alt="" src="HCSR04/potar.jpeg" /></td>
<td align="center"><img alt="" src="HCSR04/MontagePhoto.png" /></td>
<td align="center"><img alt="" src="HCSR04/Montage.png" /></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p><strong>Figure:</strong> Using the HC-SR04 with the micro:bit: set the potentiometer to its mid-position, do the wiring. </p>
</div>
<p>One way to use the HC-SR04 in our program is to use the following function:</p>
<pre><code class="py">from microbit import *
import machine
import utime

pinTrig = pin0
pinEcho = pin1
pinEcho.set_pull(pinEcho.NO_PULL) # some electronics that we can't explain you now

def get_dist_in_cm():
    # send a high pulse to the trigger of HC-SR04
    pinTrig.write_digital(0)
    utime.sleep_us(2)
    pinTrig.write_digital(1)
    utime.sleep_us(10)
    pinTrig.write_digital(0)

    # measure the time in microseconds that it takes to receive a high pulse on the echo pin.   
    d = machine.time_pulse_us(pinEcho,1,10000)# timeout in 10000 us = 0.01 s
    if d&gt;0:# echo received
        return d/Constant
    else:# timeout returns -1   
        return d
</code></pre>

<div class="admonition note">
<p class="admonition-title">exercise 3</p>
<ul>
<li>3.1. Read the code to verify if it matches the sensor specifications that we defined previously. Will this work if I call the function <em>get_dist_in_cm()</em> ?</li>
<li>3.2. It won't work ! There is something missing: <em>Constant</em> is not defined and that's because I want you to find it now using the laws of physics.</li>
<li>3.3. Once you found the value of <em>Constant</em>, write a program to display the distance on the LED matrix using the function <em>display.scroll()</em>.  What is the range of distance the sensor can perceive ? Don't forget to turn the switch of the buggy board on to test your program. When the switch is on you can actually unplug the usb cable and the circuit should continue working without the computer.</li>
<li>3.4. Display the distance on the LED matrix using the function <em>displayPositiveNumber(n)</em>. </li>
</ul>
</div>
<h2 id="disco-light-optional">Disco light (optional)</h2>
<p><img alt="" src="discoLight.gif" /></p>
<div class="admonition note">
<p><strong>Figure:</strong> Controlling neopixel LEDs with the potentiometer (and showing the rgb values on the LED matrix)</p>
</div>
<p>If you finish the exercises in advance or if you are not tired enough and you want to learn more, one more thing you could do is to use the special extension board of the buggy, and learn to control it. </p>
<p><strong>Warning:</strong> Before doing this activity <strong>remove the batteries</strong> from the buggy mainboard. Indeed, you will use the potentiometer as a sensor. If you kept the batteries it could provide, depending on the knob position, a voltage going from 0 to 5 Volts to the micro:bit. And as we learned previously 5V is likely to burn the micro:bit. By removing the batteries, the voltage will be in between 0 and 3.3V which is perfect.</p>
<p>The special extension board of the buggy comes with 2 neopixel LEDs which can be controlled thanks to the neopixel library. For instance, if the board is plugged on pin0, a simple program to light up one LED in green and one in blue would be the following:</p>
<pre><code class="py">from microbit import *
import neopixel

np = neopixel.NeoPixel(pin0, 2)
np[0] = (0, 255, 0)
np[1] = (0, 0, 255)
np.show()
</code></pre>

<div class="admonition note">
<p class="admonition-title">exercise 4</p>
<p>Connect the neopixel and the potentiometer to the micro.bit. Program the micro:bit to change the colors of the LEDs with the sensors at your disposition, making it as user friendly as possible.</p>
</div>
<h2 id="conclusion">Conclusion</h2>
<p>That's it for today. Turn the buggy mainboard off using it's switch to save the batteries for the coming days and unplug everything putting all the components back to their respective boxes.</p>
<p>With what you've learned today, you've got all the electronics tools you need to make an autonomous robot. While this morning you learned to interact with the controller of a robot, now you know how to give it eyes and muscles. Moreover while your familiarity with the use of functions is growing, reusing the work we did today will get easier and easier. The function <em>displayPositiveNumber(n)</em> made our work easier this afternoon to get a quick feedback from our sensors. All the work we did with the motor and the distance sensor this afternoon will make our work easier in the coming days. </p>
<p>Talking about ease: this afternoon we dabbled in the world of electronics. This can be intimidating at first. But like most other domains, by repetitive explorations out of your confort zone, you make your confort zone wider and soon this field can be yours to play with. For now, time to rest and see you tomorrow for some more challenges !</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>While we use the potentiometer as a sensor it is essentially a voltage divider. Therefore we can use it to lower the voltage of the echo signal down. </p>
<p>The way we used it as a sensor was to connect it with 3.3V and the ground, and it outputed a portion of 3.3V depending on the position of the knob, which is what we measured with the micro:bit. Instead, we can now feed it with the 0 to 5V echo signal coming from the HC-SR04, and make it output a portion of that, making sure it does not go over 3.3V. Also we need to take a sufficiently large portion of the signal, for instance imagine we outputed 0% of the signal with the potentiometer, then we would not be able to understand when the echo is received on the micro:bit. To get it to work we need the high value of the signal to be 2.3 Volt minimum (2.3 = 0.7 * 3.3... see <a href="https://tech.microbit.org/hardware/edgeconnector/">here</a> for more information). Therefore if we put the knob at its mid position, it should output a signal oscillating in between 0 and 2.5V and it should work.&#160;<a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>
              
            </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
